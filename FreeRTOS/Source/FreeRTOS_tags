!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ATOMIC_COMPARE_AND_SWAP_FAILURE	include/atomic.h	91;"	d
ATOMIC_COMPARE_AND_SWAP_SUCCESS	include/atomic.h	90;"	d
ATOMIC_ENTER_CRITICAL	include/atomic.h	65;"	d
ATOMIC_ENTER_CRITICAL	include/atomic.h	74;"	d
ATOMIC_EXIT_CRITICAL	include/atomic.h	68;"	d
ATOMIC_EXIT_CRITICAL	include/atomic.h	75;"	d
ATOMIC_H	include/atomic.h	39;"	d
A_BLOCK_LINK	portable/MemMang/heap_2.c	/^typedef struct A_BLOCK_LINK$/;"	s	file:
A_BLOCK_LINK	portable/MemMang/heap_4.c	/^typedef struct A_BLOCK_LINK$/;"	s	file:
A_BLOCK_LINK	portable/MemMang/heap_5.c	/^typedef struct A_BLOCK_LINK$/;"	s	file:
A_BLOCK_LINK::pxNextFreeBlock	portable/MemMang/heap_2.c	/^    struct A_BLOCK_LINK * pxNextFreeBlock; \/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:	access:public
A_BLOCK_LINK::pxNextFreeBlock	portable/MemMang/heap_4.c	/^    struct A_BLOCK_LINK * pxNextFreeBlock; \/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:	access:public
A_BLOCK_LINK::pxNextFreeBlock	portable/MemMang/heap_5.c	/^    struct A_BLOCK_LINK * pxNextFreeBlock; \/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:	access:public
A_BLOCK_LINK::xBlockSize	portable/MemMang/heap_2.c	/^    size_t xBlockSize;                     \/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:	access:public
A_BLOCK_LINK::xBlockSize	portable/MemMang/heap_4.c	/^    size_t xBlockSize;                     \/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:	access:public
A_BLOCK_LINK::xBlockSize	portable/MemMang/heap_5.c	/^    size_t xBlockSize;                     \/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:	access:public
Atomic_AND_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_AND_u32( uint32_t volatile * pulDestination,$/;"	f	signature:( uint32_t volatile * pulDestination, uint32_t ulValue )
Atomic_Add_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_Add_u32( uint32_t volatile * pulAddend,$/;"	f	signature:( uint32_t volatile * pulAddend, uint32_t ulCount )
Atomic_CompareAndSwapPointers_p32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_CompareAndSwapPointers_p32( void * volatile * ppvDestination,$/;"	f	signature:( void * volatile * ppvDestination, void * pvExchange, void * pvComparand )
Atomic_CompareAndSwap_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_CompareAndSwap_u32( uint32_t volatile * pulDestination,$/;"	f	signature:( uint32_t volatile * pulDestination, uint32_t ulExchange, uint32_t ulComparand )
Atomic_Decrement_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_Decrement_u32( uint32_t volatile * pulAddend )$/;"	f	signature:( uint32_t volatile * pulAddend )
Atomic_Increment_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_Increment_u32( uint32_t volatile * pulAddend )$/;"	f	signature:( uint32_t volatile * pulAddend )
Atomic_NAND_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_NAND_u32( uint32_t volatile * pulDestination,$/;"	f	signature:( uint32_t volatile * pulDestination, uint32_t ulValue )
Atomic_OR_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_OR_u32( uint32_t volatile * pulDestination,$/;"	f	signature:( uint32_t volatile * pulDestination, uint32_t ulValue )
Atomic_Subtract_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_Subtract_u32( uint32_t volatile * pulAddend,$/;"	f	signature:( uint32_t volatile * pulAddend, uint32_t ulCount )
Atomic_SwapPointers_p32	include/atomic.h	/^static portFORCE_INLINE void * Atomic_SwapPointers_p32( void * volatile * ppvDestination,$/;"	f	signature:( void * volatile * ppvDestination, void * pvExchange )
Atomic_XOR_u32	include/atomic.h	/^static portFORCE_INLINE uint32_t Atomic_XOR_u32( uint32_t volatile * pulDestination,$/;"	f	signature:( uint32_t volatile * pulDestination, uint32_t ulValue )
BaseType_t	portable/ThirdParty/GCC/Posix/portmacro.h	/^typedef long BaseType_t;$/;"	t
BlockLink_t	portable/MemMang/heap_2.c	/^} BlockLink_t;$/;"	t	typeref:struct:A_BLOCK_LINK	file:
BlockLink_t	portable/MemMang/heap_4.c	/^} BlockLink_t;$/;"	t	typeref:struct:A_BLOCK_LINK	file:
BlockLink_t	portable/MemMang/heap_5.c	/^} BlockLink_t;$/;"	t	typeref:struct:A_BLOCK_LINK	file:
CO_ROUTINE_H	include/croutine.h	30;"	d
CRCB_t	include/croutine.h	/^} CRCB_t;                        \/* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. *\/$/;"	t	typeref:struct:corCoRoutineControlBlock
CallbackParameters_t	timers.c	/^    } CallbackParameters_t;$/;"	t	typeref:struct:tmrCallbackParameters	file:
CoRoutineHandle_t	include/croutine.h	/^typedef void * CoRoutineHandle_t;$/;"	t
DEPRECATED_DEFINITIONS_H	include/deprecated_definitions.h	30;"	d
DaemonTaskMessage_t	timers.c	/^    } DaemonTaskMessage_t;$/;"	t	typeref:struct:tmrTimerQueueMessage	file:
EVENT_GROUPS_H	include/event_groups.h	30;"	d
EventBits_t	include/event_groups.h	/^typedef TickType_t               EventBits_t;$/;"	t
EventGroupDef_t	event_groups.c	/^typedef struct EventGroupDef_t$/;"	s	file:
EventGroupDef_t::ucStaticallyAllocated	event_groups.c	/^        uint8_t ucStaticallyAllocated; \/*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:EventGroupDef_t	file:	access:public
EventGroupDef_t::uxEventBits	event_groups.c	/^    EventBits_t uxEventBits;$/;"	m	struct:EventGroupDef_t	file:	access:public
EventGroupDef_t::uxEventGroupNumber	event_groups.c	/^        UBaseType_t uxEventGroupNumber;$/;"	m	struct:EventGroupDef_t	file:	access:public
EventGroupDef_t::xTasksWaitingForBits	event_groups.c	/^    List_t xTasksWaitingForBits; \/*< List of tasks waiting for a bit to be set. *\/$/;"	m	struct:EventGroupDef_t	file:	access:public
EventGroupHandle_t	include/event_groups.h	/^typedef struct EventGroupDef_t   * EventGroupHandle_t;$/;"	t	typeref:struct:EventGroupDef_t
EventGroup_t	event_groups.c	/^} EventGroup_t;$/;"	t	typeref:struct:EventGroupDef_t	file:
FREERTOS_MESSAGE_BUFFER_H	include/message_buffer.h	64;"	d
FREERTOS_SYSTEM_CALL	include/mpu_wrappers.h	166;"	d
FREERTOS_SYSTEM_CALL	include/mpu_wrappers.h	173;"	d
FREERTOS_SYSTEM_CALL	include/mpu_wrappers.h	181;"	d
FreeRTOS_errno	tasks.c	/^    int FreeRTOS_errno = 0;$/;"	v
HeapRegion	include/portable.h	/^typedef struct HeapRegion$/;"	s
HeapRegion::pucStartAddress	include/portable.h	/^    uint8_t * pucStartAddress;$/;"	m	struct:HeapRegion	access:public
HeapRegion::xSizeInBytes	include/portable.h	/^    size_t xSizeInBytes;$/;"	m	struct:HeapRegion	access:public
HeapRegion_t	include/portable.h	/^} HeapRegion_t;$/;"	t	typeref:struct:HeapRegion
HeapStats_t	include/portable.h	/^} HeapStats_t;$/;"	t	typeref:struct:xHeapStats
INCLUDE_eTaskGetState	include/FreeRTOS.h	188;"	d
INCLUDE_uxTaskGetStackHighWaterMark	include/FreeRTOS.h	180;"	d
INCLUDE_uxTaskGetStackHighWaterMark2	include/FreeRTOS.h	184;"	d
INCLUDE_uxTaskPriorityGet	include/FreeRTOS.h	120;"	d
INCLUDE_vTaskDelay	include/FreeRTOS.h	156;"	d
INCLUDE_vTaskDelete	include/FreeRTOS.h	124;"	d
INCLUDE_vTaskPrioritySet	include/FreeRTOS.h	116;"	d
INCLUDE_vTaskSuspend	include/FreeRTOS.h	128;"	d
INCLUDE_xQueueGetMutexHolder	include/FreeRTOS.h	168;"	d
INCLUDE_xSemaphoreGetMutexHolder	include/FreeRTOS.h	172;"	d
INCLUDE_xTaskAbortDelay	include/FreeRTOS.h	164;"	d
INCLUDE_xTaskDelayUntil	include/FreeRTOS.h	147;"	d
INCLUDE_xTaskDelayUntil	include/FreeRTOS.h	152;"	d
INCLUDE_xTaskGetCurrentTaskHandle	include/FreeRTOS.h	204;"	d
INCLUDE_xTaskGetHandle	include/FreeRTOS.h	176;"	d
INCLUDE_xTaskGetIdleTaskHandle	include/FreeRTOS.h	160;"	d
INCLUDE_xTaskGetSchedulerState	include/FreeRTOS.h	200;"	d
INCLUDE_xTaskResumeFromISR	include/FreeRTOS.h	192;"	d
INCLUDE_xTimerPendFunctionCall	include/FreeRTOS.h	196;"	d
INC_FREERTOS_H	include/FreeRTOS.h	30;"	d
INC_TASK_H	include/task.h	31;"	d
LIST_H	include/list.h	59;"	d
ListItem_t	include/list.h	/^typedef struct xLIST_ITEM ListItem_t;                   \/* For some reason lint wants this as two separate definitions. *\/$/;"	t	typeref:struct:xLIST_ITEM
List_t	include/list.h	/^} List_t;$/;"	t	typeref:struct:xLIST
MPU_PROTOTYPES_H	include/mpu_prototypes.h	39;"	d
MPU_WRAPPERS_H	include/mpu_wrappers.h	30;"	d
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	event_groups.c	35;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	event_groups.c	47;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	list.c	35;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	list.c	44;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/Common/mpu_wrappers.c	37;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/Common/mpu_wrappers.c	48;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_1.c	42;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_1.c	47;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_2.c	43;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_2.c	48;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_3.c	46;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_3.c	51;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_4.c	42;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_4.c	47;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_5.c	76;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_5.c	81;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	queue.c	35;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	queue.c	49;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	stream_buffer.c	36;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	stream_buffer.c	51;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	tasks.c	36;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	tasks.c	48;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	timers.c	35;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	timers.c	50;"	d	file:
MPU_eTaskGetState	portable/Common/mpu_wrappers.c	/^    eTaskState MPU_eTaskGetState( TaskHandle_t pxTask ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t pxTask )
MPU_pcQueueGetName	portable/Common/mpu_wrappers.c	/^    const char * MPU_pcQueueGetName( QueueHandle_t xQueue ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( QueueHandle_t xQueue )
MPU_pcTaskGetName	portable/Common/mpu_wrappers.c	/^char * MPU_pcTaskGetName( TaskHandle_t xTaskToQuery ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t xTaskToQuery )
MPU_pcTimerGetName	portable/Common/mpu_wrappers.c	/^    const char * MPU_pcTimerGetName( TimerHandle_t xTimer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TimerHandle_t xTimer )
MPU_pvTaskGetThreadLocalStoragePointer	portable/Common/mpu_wrappers.c	/^    void * MPU_pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,$/;"	f	signature:( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
MPU_pvTimerGetTimerID	portable/Common/mpu_wrappers.c	/^    void * MPU_pvTimerGetTimerID( const TimerHandle_t xTimer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( const TimerHandle_t xTimer )
MPU_ulTaskGenericNotifyTake	portable/Common/mpu_wrappers.c	/^    uint32_t MPU_ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,$/;"	f	signature:( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
MPU_ulTaskGenericNotifyValueClear	portable/Common/mpu_wrappers.c	/^    uint32_t MPU_ulTaskGenericNotifyValueClear( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear )
MPU_ulTaskGetIdleRunTimeCounter	portable/Common/mpu_wrappers.c	/^    uint32_t MPU_ulTaskGetIdleRunTimeCounter( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_uxQueueMessagesWaiting	portable/Common/mpu_wrappers.c	/^UBaseType_t MPU_uxQueueMessagesWaiting( const QueueHandle_t pxQueue ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( const QueueHandle_t pxQueue )
MPU_uxQueueSpacesAvailable	portable/Common/mpu_wrappers.c	/^UBaseType_t MPU_uxQueueSpacesAvailable( const QueueHandle_t xQueue ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( const QueueHandle_t xQueue )
MPU_uxTaskGetNumberOfTasks	portable/Common/mpu_wrappers.c	/^UBaseType_t MPU_uxTaskGetNumberOfTasks( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_uxTaskGetStackHighWaterMark	portable/Common/mpu_wrappers.c	/^    UBaseType_t MPU_uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t xTask )
MPU_uxTaskGetStackHighWaterMark2	portable/Common/mpu_wrappers.c	/^    configSTACK_DEPTH_TYPE MPU_uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t xTask )
MPU_uxTaskGetSystemState	portable/Common/mpu_wrappers.c	/^    UBaseType_t MPU_uxTaskGetSystemState( TaskStatus_t * pxTaskStatusArray,$/;"	f	signature:( TaskStatus_t * pxTaskStatusArray, UBaseType_t uxArraySize, uint32_t * pulTotalRunTime )
MPU_uxTaskPriorityGet	portable/Common/mpu_wrappers.c	/^    UBaseType_t MPU_uxTaskPriorityGet( const TaskHandle_t pxTask ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( const TaskHandle_t pxTask )
MPU_uxTimerGetReloadMode	portable/Common/mpu_wrappers.c	/^    UBaseType_t MPU_uxTimerGetReloadMode( TimerHandle_t xTimer )$/;"	f	signature:( TimerHandle_t xTimer )
MPU_vEventGroupDelete	portable/Common/mpu_wrappers.c	/^void MPU_vEventGroupDelete( EventGroupHandle_t xEventGroup ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( EventGroupHandle_t xEventGroup )
MPU_vPortInitialiseBlocks	portable/Common/mpu_wrappers.c	/^    void MPU_vPortInitialiseBlocks( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_vQueueAddToRegistry	portable/Common/mpu_wrappers.c	/^    void MPU_vQueueAddToRegistry( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, const char * pcName )
MPU_vQueueDelete	portable/Common/mpu_wrappers.c	/^void MPU_vQueueDelete( QueueHandle_t xQueue ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( QueueHandle_t xQueue )
MPU_vQueueUnregisterQueue	portable/Common/mpu_wrappers.c	/^    void MPU_vQueueUnregisterQueue( QueueHandle_t xQueue ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( QueueHandle_t xQueue )
MPU_vStreamBufferDelete	portable/Common/mpu_wrappers.c	/^void MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
MPU_vTaskDelay	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskDelay( TickType_t xTicksToDelay ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TickType_t xTicksToDelay )
MPU_vTaskDelete	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskDelete( TaskHandle_t pxTaskToDelete ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t pxTaskToDelete )
MPU_vTaskGetInfo	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskGetInfo( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, TaskStatus_t * pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
MPU_vTaskGetRunTimeStats	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskGetRunTimeStats( char * pcWriteBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( char * pcWriteBuffer )
MPU_vTaskList	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskList( char * pcWriteBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( char * pcWriteBuffer )
MPU_vTaskPrioritySet	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskPrioritySet( TaskHandle_t pxTask,$/;"	f	signature:( TaskHandle_t pxTask, UBaseType_t uxNewPriority )
MPU_vTaskResume	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskResume( TaskHandle_t pxTaskToResume ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t pxTaskToResume )
MPU_vTaskSetApplicationTaskTag	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskSetApplicationTaskTag( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, TaskHookFunction_t pxTagValue )
MPU_vTaskSetThreadLocalStoragePointer	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,$/;"	f	signature:( TaskHandle_t xTaskToSet, BaseType_t xIndex, void * pvValue )
MPU_vTaskSetTimeOutState	portable/Common/mpu_wrappers.c	/^void MPU_vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TimeOut_t * const pxTimeOut )
MPU_vTaskSuspend	portable/Common/mpu_wrappers.c	/^    void MPU_vTaskSuspend( TaskHandle_t pxTaskToSuspend ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t pxTaskToSuspend )
MPU_vTaskSuspendAll	portable/Common/mpu_wrappers.c	/^void MPU_vTaskSuspendAll( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_vTimerSetReloadMode	portable/Common/mpu_wrappers.c	/^    void MPU_vTimerSetReloadMode( TimerHandle_t xTimer,$/;"	f	signature:( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
MPU_vTimerSetTimerID	portable/Common/mpu_wrappers.c	/^    void MPU_vTimerSetTimerID( TimerHandle_t xTimer,$/;"	f	signature:( TimerHandle_t xTimer, void * pvNewID )
MPU_xEventGroupClearBits	portable/Common/mpu_wrappers.c	/^EventBits_t MPU_xEventGroupClearBits( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
MPU_xEventGroupCreate	portable/Common/mpu_wrappers.c	/^    EventGroupHandle_t MPU_xEventGroupCreate( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_xEventGroupCreateStatic	portable/Common/mpu_wrappers.c	/^    EventGroupHandle_t MPU_xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( StaticEventGroup_t * pxEventGroupBuffer )
MPU_xEventGroupSetBits	portable/Common/mpu_wrappers.c	/^EventBits_t MPU_xEventGroupSetBits( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
MPU_xEventGroupSync	portable/Common/mpu_wrappers.c	/^EventBits_t MPU_xEventGroupSync( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
MPU_xEventGroupWaitBits	portable/Common/mpu_wrappers.c	/^EventBits_t MPU_xEventGroupWaitBits( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
MPU_xPortGetFreeHeapSize	portable/Common/mpu_wrappers.c	/^    size_t MPU_xPortGetFreeHeapSize( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_xQueueAddToSet	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,$/;"	f	signature:( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
MPU_xQueueCreateCountingSemaphore	portable/Common/mpu_wrappers.c	/^    QueueHandle_t MPU_xQueueCreateCountingSemaphore( UBaseType_t uxCountValue,$/;"	f	signature:( UBaseType_t uxCountValue, UBaseType_t uxInitialCount )
MPU_xQueueCreateCountingSemaphoreStatic	portable/Common/mpu_wrappers.c	/^    QueueHandle_t MPU_xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,$/;"	f	signature:( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t * pxStaticQueue )
MPU_xQueueCreateMutex	portable/Common/mpu_wrappers.c	/^    QueueHandle_t MPU_xQueueCreateMutex( const uint8_t ucQueueType ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( const uint8_t ucQueueType )
MPU_xQueueCreateMutexStatic	portable/Common/mpu_wrappers.c	/^    QueueHandle_t MPU_xQueueCreateMutexStatic( const uint8_t ucQueueType,$/;"	f	signature:( const uint8_t ucQueueType, StaticQueue_t * pxStaticQueue )
MPU_xQueueCreateSet	portable/Common/mpu_wrappers.c	/^    QueueSetHandle_t MPU_xQueueCreateSet( UBaseType_t uxEventQueueLength ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( UBaseType_t uxEventQueueLength )
MPU_xQueueGenericCreate	portable/Common/mpu_wrappers.c	/^    QueueHandle_t MPU_xQueueGenericCreate( UBaseType_t uxQueueLength,$/;"	f	signature:( UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t ucQueueType )
MPU_xQueueGenericCreateStatic	portable/Common/mpu_wrappers.c	/^    QueueHandle_t MPU_xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,$/;"	f	signature:( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t * pucQueueStorage, StaticQueue_t * pxStaticQueue, const uint8_t ucQueueType )
MPU_xQueueGenericReset	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xQueueGenericReset( QueueHandle_t pxQueue,$/;"	f	signature:( QueueHandle_t pxQueue, BaseType_t xNewQueue )
MPU_xQueueGenericSend	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xQueueGenericSend( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition )
MPU_xQueueGetMutexHolder	portable/Common/mpu_wrappers.c	/^    TaskHandle_t MPU_xQueueGetMutexHolder( QueueHandle_t xSemaphore ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( QueueHandle_t xSemaphore )
MPU_xQueueGiveMutexRecursive	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xQueueGiveMutexRecursive( QueueHandle_t xMutex ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( QueueHandle_t xMutex )
MPU_xQueuePeek	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xQueuePeek( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
MPU_xQueueReceive	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xQueueReceive( QueueHandle_t pxQueue,$/;"	f	signature:( QueueHandle_t pxQueue, void * const pvBuffer, TickType_t xTicksToWait )
MPU_xQueueRemoveFromSet	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore,$/;"	f	signature:( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
MPU_xQueueSelectFromSet	portable/Common/mpu_wrappers.c	/^    QueueSetMemberHandle_t MPU_xQueueSelectFromSet( QueueSetHandle_t xQueueSet,$/;"	f	signature:( QueueSetHandle_t xQueueSet, TickType_t xBlockTimeTicks )
MPU_xQueueSemaphoreTake	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xQueueSemaphoreTake( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, TickType_t xTicksToWait )
MPU_xQueueTakeMutexRecursive	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xQueueTakeMutexRecursive( QueueHandle_t xMutex,$/;"	f	signature:( QueueHandle_t xMutex, TickType_t xBlockTime )
MPU_xStreamBufferBytesAvailable	portable/Common/mpu_wrappers.c	/^size_t MPU_xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
MPU_xStreamBufferGenericCreate	portable/Common/mpu_wrappers.c	/^    StreamBufferHandle_t MPU_xStreamBufferGenericCreate( size_t xBufferSizeBytes,$/;"	f	signature:( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
MPU_xStreamBufferGenericCreateStatic	portable/Common/mpu_wrappers.c	/^    StreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,$/;"	f	signature:( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t * const pucStreamBufferStorageArea, StaticStreamBuffer_t * const pxStaticStreamBuffer )
MPU_xStreamBufferIsEmpty	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
MPU_xStreamBufferIsFull	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
MPU_xStreamBufferNextMessageLengthBytes	portable/Common/mpu_wrappers.c	/^size_t MPU_xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
MPU_xStreamBufferReceive	portable/Common/mpu_wrappers.c	/^size_t MPU_xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait )
MPU_xStreamBufferReset	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
MPU_xStreamBufferSend	portable/Common/mpu_wrappers.c	/^size_t MPU_xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait )
MPU_xStreamBufferSetTriggerLevel	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
MPU_xStreamBufferSpacesAvailable	portable/Common/mpu_wrappers.c	/^size_t MPU_xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
MPU_xTaskAbortDelay	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTaskAbortDelay( TaskHandle_t xTask ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t xTask )
MPU_xTaskCallApplicationTaskHook	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTaskCallApplicationTaskHook( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, void * pvParameter )
MPU_xTaskCatchUpTicks	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TickType_t xTicksToCatchUp )
MPU_xTaskCheckForTimeOut	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,$/;"	f	signature:( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
MPU_xTaskCreate	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTaskCreate( TaskFunction_t pvTaskCode,$/;"	f	signature:( TaskFunction_t pvTaskCode, const char * const pcName, uint16_t usStackDepth, void * pvParameters, UBaseType_t uxPriority, TaskHandle_t * pxCreatedTask )
MPU_xTaskCreateStatic	portable/Common/mpu_wrappers.c	/^    TaskHandle_t MPU_xTaskCreateStatic( TaskFunction_t pxTaskCode,$/;"	f	signature:( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer )
MPU_xTaskDelayUntil	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,$/;"	f	signature:( TickType_t * const pxPreviousWakeTime, TickType_t xTimeIncrement )
MPU_xTaskGenericNotify	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTaskGenericNotify( TaskHandle_t xTaskToNotify,$/;"	f	signature:( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t * pulPreviousNotificationValue )
MPU_xTaskGenericNotifyStateClear	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTaskGenericNotifyStateClear( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, UBaseType_t uxIndexToClear )
MPU_xTaskGenericNotifyWait	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,$/;"	f	signature:( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t * pulNotificationValue, TickType_t xTicksToWait )
MPU_xTaskGetApplicationTaskTag	portable/Common/mpu_wrappers.c	/^    TaskHookFunction_t MPU_xTaskGetApplicationTaskTag( TaskHandle_t xTask ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TaskHandle_t xTask )
MPU_xTaskGetCurrentTaskHandle	portable/Common/mpu_wrappers.c	/^    TaskHandle_t MPU_xTaskGetCurrentTaskHandle( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_xTaskGetHandle	portable/Common/mpu_wrappers.c	/^    TaskHandle_t MPU_xTaskGetHandle( const char * pcNameToQuery ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( const char * pcNameToQuery )
MPU_xTaskGetIdleTaskHandle	portable/Common/mpu_wrappers.c	/^    TaskHandle_t MPU_xTaskGetIdleTaskHandle( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_xTaskGetSchedulerState	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTaskGetSchedulerState( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_xTaskGetTickCount	portable/Common/mpu_wrappers.c	/^TickType_t MPU_xTaskGetTickCount( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_xTaskResumeAll	portable/Common/mpu_wrappers.c	/^BaseType_t MPU_xTaskResumeAll( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_xTimerCreate	portable/Common/mpu_wrappers.c	/^    TimerHandle_t MPU_xTimerCreate( const char * const pcTimerName,$/;"	f	signature:( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction )
MPU_xTimerCreateStatic	portable/Common/mpu_wrappers.c	/^    TimerHandle_t MPU_xTimerCreateStatic( const char * const pcTimerName,$/;"	f	signature:( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t * pxTimerBuffer )
MPU_xTimerGenericCommand	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTimerGenericCommand( TimerHandle_t xTimer,$/;"	f	signature:( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
MPU_xTimerGetExpiryTime	portable/Common/mpu_wrappers.c	/^    TickType_t MPU_xTimerGetExpiryTime( TimerHandle_t xTimer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TimerHandle_t xTimer )
MPU_xTimerGetPeriod	portable/Common/mpu_wrappers.c	/^    TickType_t MPU_xTimerGetPeriod( TimerHandle_t xTimer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TimerHandle_t xTimer )
MPU_xTimerGetTimerDaemonTaskHandle	portable/Common/mpu_wrappers.c	/^    TaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
MPU_xTimerIsTimerActive	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTimerIsTimerActive( TimerHandle_t xTimer ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( TimerHandle_t xTimer )
MPU_xTimerPendFunctionCall	portable/Common/mpu_wrappers.c	/^    BaseType_t MPU_xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,$/;"	f	signature:( PendedFunction_t xFunctionToPend, void * pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
MemoryRegion_t	include/task.h	/^} MemoryRegion_t;$/;"	t	typeref:struct:xMEMORY_REGION
MessageBufferHandle_t	include/message_buffer.h	/^typedef void * MessageBufferHandle_t;$/;"	t
MiniListItem_t	include/list.h	/^typedef struct xMINI_LIST_ITEM MiniListItem_t;$/;"	t	typeref:struct:xMINI_LIST_ITEM
PORTABLE_H	include/portable.h	34;"	d
PORTMACRO_H	portable/ThirdParty/GCC/Posix/portmacro.h	31;"	d
PRIVILEGED_DATA	include/mpu_wrappers.h	165;"	d
PRIVILEGED_DATA	include/mpu_wrappers.h	172;"	d
PRIVILEGED_DATA	include/mpu_wrappers.h	180;"	d
PRIVILEGED_FUNCTION	include/mpu_wrappers.h	164;"	d
PRIVILEGED_FUNCTION	include/mpu_wrappers.h	171;"	d
PRIVILEGED_FUNCTION	include/mpu_wrappers.h	179;"	d
PROJDEFS_H	include/projdefs.h	30;"	d
PendedFunction_t	include/timers.h	/^typedef void (* PendedFunction_t)( void *,$/;"	t
QUEUE_H	include/queue.h	31;"	d
QUEUE_REGISTRY_ITEM	queue.c	/^    typedef struct QUEUE_REGISTRY_ITEM$/;"	s	file:
QUEUE_REGISTRY_ITEM::pcQueueName	queue.c	/^        const char * pcQueueName; \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:	access:public
QUEUE_REGISTRY_ITEM::xHandle	queue.c	/^        QueueHandle_t xHandle;$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:	access:public
QueueDefinition	queue.c	/^typedef struct QueueDefinition \/* The old naming convention is used to prevent breaking kernel aware debuggers. *\/$/;"	s	file:
QueueDefinition::__anon2::xQueue	queue.c	/^        QueuePointers_t xQueue;     \/*< Data required exclusively when this structure is used as a queue. *\/$/;"	m	union:QueueDefinition::__anon2	file:	access:public
QueueDefinition::__anon2::xSemaphore	queue.c	/^        SemaphoreData_t xSemaphore; \/*< Data required exclusively when this structure is used as a semaphore. *\/$/;"	m	union:QueueDefinition::__anon2	file:	access:public
QueueDefinition::cRxLock	queue.c	/^    volatile int8_t cRxLock;                \/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::cTxLock	queue.c	/^    volatile int8_t cTxLock;                \/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::pcHead	queue.c	/^    int8_t * pcHead;           \/*< Points to the beginning of the queue storage area. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::pcWriteTo	queue.c	/^    int8_t * pcWriteTo;        \/*< Points to the free next place in the storage area. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::pxQueueSetContainer	queue.c	/^        struct QueueDefinition * pxQueueSetContainer;$/;"	m	struct:QueueDefinition	typeref:struct:QueueDefinition::QueueDefinition	file:	access:public
QueueDefinition::u	queue.c	/^    } u;$/;"	m	struct:QueueDefinition	typeref:union:QueueDefinition::__anon2	file:	access:public
QueueDefinition::ucQueueType	queue.c	/^        uint8_t ucQueueType;$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::ucStaticallyAllocated	queue.c	/^        uint8_t ucStaticallyAllocated; \/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::uxItemSize	queue.c	/^    UBaseType_t uxItemSize;                 \/*< The size of each items that the queue will hold. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::uxLength	queue.c	/^    UBaseType_t uxLength;                   \/*< The length of the queue defined as the number of items it will hold, not the number of bytes. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::uxMessagesWaiting	queue.c	/^    volatile UBaseType_t uxMessagesWaiting; \/*< The number of items currently in the queue. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::uxQueueNumber	queue.c	/^        UBaseType_t uxQueueNumber;$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::xTasksWaitingToReceive	queue.c	/^    List_t xTasksWaitingToReceive;          \/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueDefinition::xTasksWaitingToSend	queue.c	/^    List_t xTasksWaitingToSend;             \/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:	access:public
QueueHandle_t	include/queue.h	/^typedef struct QueueDefinition   * QueueHandle_t;$/;"	t	typeref:struct:QueueDefinition
QueuePointers	queue.c	/^typedef struct QueuePointers$/;"	s	file:
QueuePointers::pcReadFrom	queue.c	/^    int8_t * pcReadFrom; \/*< Points to the last place that a queued item was read from when the structure is used as a queue. *\/$/;"	m	struct:QueuePointers	file:	access:public
QueuePointers::pcTail	queue.c	/^    int8_t * pcTail;     \/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. *\/$/;"	m	struct:QueuePointers	file:	access:public
QueuePointers_t	queue.c	/^} QueuePointers_t;$/;"	t	typeref:struct:QueuePointers	file:
QueueRegistryItem_t	queue.c	/^    typedef xQueueRegistryItem QueueRegistryItem_t;$/;"	t	file:
QueueSetHandle_t	include/queue.h	/^typedef struct QueueDefinition   * QueueSetHandle_t;$/;"	t	typeref:struct:QueueDefinition
QueueSetMemberHandle_t	include/queue.h	/^typedef struct QueueDefinition   * QueueSetMemberHandle_t;$/;"	t	typeref:struct:QueueDefinition
Queue_t	queue.c	/^typedef xQUEUE Queue_t;$/;"	t	file:
SEMAPHORE_H	include/semphr.h	30;"	d
SIG_RESUME	portable/ThirdParty/GCC/Posix/port.c	70;"	d	file:
STACK_MACROS_H	include/stack_macros.h	30;"	d
STREAM_BUFFER_H	include/stream_buffer.h	53;"	d
SemaphoreData	queue.c	/^typedef struct SemaphoreData$/;"	s	file:
SemaphoreData::uxRecursiveCallCount	queue.c	/^    UBaseType_t uxRecursiveCallCount; \/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. *\/$/;"	m	struct:SemaphoreData	file:	access:public
SemaphoreData::xMutexHolder	queue.c	/^    TaskHandle_t xMutexHolder;        \/*< The handle of the task that holds the mutex. *\/$/;"	m	struct:SemaphoreData	file:	access:public
SemaphoreData_t	queue.c	/^} SemaphoreData_t;$/;"	t	typeref:struct:SemaphoreData	file:
SemaphoreHandle_t	include/semphr.h	/^typedef QueueHandle_t SemaphoreHandle_t;$/;"	t
StackType_t	portable/ThirdParty/GCC/Posix/portmacro.h	/^typedef portSTACK_TYPE StackType_t;$/;"	t
StaticEventGroup_t	include/FreeRTOS.h	/^} StaticEventGroup_t;$/;"	t	typeref:struct:xSTATIC_EVENT_GROUP
StaticListItem_t	include/FreeRTOS.h	/^typedef struct xSTATIC_LIST_ITEM StaticListItem_t;$/;"	t	typeref:struct:xSTATIC_LIST_ITEM
StaticList_t	include/FreeRTOS.h	/^} StaticList_t;$/;"	t	typeref:struct:xSTATIC_LIST
StaticMessageBuffer_t	include/FreeRTOS.h	/^typedef StaticStreamBuffer_t StaticMessageBuffer_t;$/;"	t
StaticMiniListItem_t	include/FreeRTOS.h	/^typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;$/;"	t	typeref:struct:xSTATIC_MINI_LIST_ITEM
StaticQueue_t	include/FreeRTOS.h	/^} StaticQueue_t;$/;"	t	typeref:struct:xSTATIC_QUEUE
StaticSemaphore_t	include/FreeRTOS.h	/^typedef StaticQueue_t StaticSemaphore_t;$/;"	t
StaticStreamBuffer_t	include/FreeRTOS.h	/^} StaticStreamBuffer_t;$/;"	t	typeref:struct:xSTATIC_STREAM_BUFFER
StaticTask_t	include/FreeRTOS.h	/^} StaticTask_t;$/;"	t	typeref:struct:xSTATIC_TCB
StaticTimer_t	include/FreeRTOS.h	/^} StaticTimer_t;$/;"	t	typeref:struct:xSTATIC_TIMER
StreamBufferDef_t	stream_buffer.c	/^typedef struct StreamBufferDef_t                 \/*lint !e9058 Style convention uses tag. *\/$/;"	s	file:
StreamBufferDef_t::pucBuffer	stream_buffer.c	/^    uint8_t * pucBuffer;                         \/* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferDef_t::ucFlags	stream_buffer.c	/^    uint8_t ucFlags;$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferDef_t::uxStreamBufferNumber	stream_buffer.c	/^        UBaseType_t uxStreamBufferNumber; \/* Used for tracing purposes. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferDef_t::xHead	stream_buffer.c	/^    volatile size_t xHead;                       \/* Index to the next item to write within the buffer. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferDef_t::xLength	stream_buffer.c	/^    size_t xLength;                              \/* The length of the buffer pointed to by pucBuffer. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferDef_t::xTail	stream_buffer.c	/^    volatile size_t xTail;                       \/* Index to the next item to read within the buffer. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferDef_t::xTaskWaitingToReceive	stream_buffer.c	/^    volatile TaskHandle_t xTaskWaitingToReceive; \/* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferDef_t::xTaskWaitingToSend	stream_buffer.c	/^    volatile TaskHandle_t xTaskWaitingToSend;    \/* Holds the handle of a task waiting to send data to a message buffer that is full. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferDef_t::xTriggerLevelBytes	stream_buffer.c	/^    size_t xTriggerLevelBytes;                   \/* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
StreamBufferHandle_t	include/stream_buffer.h	/^typedef struct StreamBufferDef_t * StreamBufferHandle_t;$/;"	t	typeref:struct:StreamBufferDef_t
StreamBuffer_t	stream_buffer.c	/^} StreamBuffer_t;$/;"	t	typeref:struct:StreamBufferDef_t	file:
TCB_t	tasks.c	/^typedef tskTCB TCB_t;$/;"	t	file:
THREAD	portable/ThirdParty/GCC/Posix/port.c	/^typedef struct THREAD$/;"	s	file:
THREAD::ev	portable/ThirdParty/GCC/Posix/port.c	/^    struct event *ev;$/;"	m	struct:THREAD	typeref:struct:THREAD::event	file:	access:public
THREAD::pthread	portable/ThirdParty/GCC/Posix/port.c	/^    pthread_t pthread;$/;"	m	struct:THREAD	file:	access:public
THREAD::pvParams	portable/ThirdParty/GCC/Posix/port.c	/^    void *pvParams;$/;"	m	struct:THREAD	file:	access:public
THREAD::pxCode	portable/ThirdParty/GCC/Posix/port.c	/^    pdTASK_CODE pxCode;$/;"	m	struct:THREAD	file:	access:public
THREAD::xDying	portable/ThirdParty/GCC/Posix/port.c	/^    BaseType_t xDying;$/;"	m	struct:THREAD	file:	access:public
TIMERS_H	include/timers.h	31;"	d
TaskFunction_t	include/projdefs.h	/^typedef void (* TaskFunction_t)( void * );$/;"	t
TaskHandle_t	include/task.h	/^typedef struct tskTaskControlBlock * TaskHandle_t;$/;"	t	typeref:struct:tskTaskControlBlock
TaskHookFunction_t	include/task.h	/^typedef BaseType_t (* TaskHookFunction_t)( void * );$/;"	t
TaskParameters_t	include/task.h	/^} TaskParameters_t;$/;"	t	typeref:struct:xTASK_PARAMETERS
TaskStatus_t	include/task.h	/^} TaskStatus_t;$/;"	t	typeref:struct:xTASK_STATUS
Thread_t	portable/ThirdParty/GCC/Posix/port.c	/^} Thread_t;$/;"	t	typeref:struct:THREAD	file:
TickType_t	portable/ThirdParty/GCC/Posix/portmacro.h	/^typedef unsigned long TickType_t;$/;"	t
TimeOut_t	include/task.h	/^} TimeOut_t;$/;"	t	typeref:struct:xTIME_OUT
TimerCallbackFunction_t	include/timers.h	/^typedef void (* TimerCallbackFunction_t)( TimerHandle_t xTimer );$/;"	t
TimerHandle_t	include/timers.h	/^typedef struct tmrTimerControl * TimerHandle_t;$/;"	t	typeref:struct:tmrTimerControl
TimerParameter_t	timers.c	/^    } TimerParameter_t;$/;"	t	typeref:struct:tmrTimerParameters	file:
Timer_t	timers.c	/^    typedef xTIMER Timer_t;$/;"	t	file:
UBaseType_t	portable/ThirdParty/GCC/Posix/portmacro.h	/^typedef unsigned long UBaseType_t;$/;"	t
_WAIT_FOR_EVENT_H_	portable/ThirdParty/GCC/Posix/utils/wait_for_event.h	30;"	d
cRxLock	queue.c	/^    volatile int8_t cRxLock;                \/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:	access:public
cTxLock	queue.c	/^    volatile int8_t cTxLock;                \/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:	access:public
cond	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^    pthread_cond_t cond;$/;"	m	struct:event	file:	access:public
configADJUSTED_HEAP_SIZE	portable/MemMang/heap_1.c	54;"	d	file:
configADJUSTED_HEAP_SIZE	portable/MemMang/heap_2.c	55;"	d	file:
configAPPLICATION_ALLOCATED_HEAP	include/FreeRTOS.h	868;"	d
configASSERT	include/FreeRTOS.h	262;"	d
configASSERT_DEFINED	include/FreeRTOS.h	263;"	d
configASSERT_DEFINED	include/FreeRTOS.h	265;"	d
configCHECK_FOR_STACK_OVERFLOW	include/FreeRTOS.h	432;"	d
configENABLE_BACKWARD_COMPATIBILITY	include/FreeRTOS.h	957;"	d
configENABLE_FPU	include/FreeRTOS.h	1044;"	d
configENABLE_MPU	include/FreeRTOS.h	1038;"	d
configENABLE_TRUSTZONE	include/FreeRTOS.h	1050;"	d
configEXPECTED_IDLE_TIME_BEFORE_SLEEP	include/FreeRTOS.h	792;"	d
configGENERATE_RUN_TIME_STATS	include/FreeRTOS.h	754;"	d
configIDLE_SHOULD_YIELD	include/FreeRTOS.h	254;"	d
configIDLE_TASK_NAME	tasks.c	115;"	d	file:
configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS	include/FreeRTOS.h	836;"	d
configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H	include/FreeRTOS.h	440;"	d
configINITIAL_TICK_COUNT	include/FreeRTOS.h	932;"	d
configLIST_VOLATILE	include/list.h	94;"	d
configMAX	include/FreeRTOS.h	979;"	d
configMAX_TASK_NAME_LEN	include/FreeRTOS.h	250;"	d
configMESSAGE_BUFFER_LENGTH_TYPE	include/FreeRTOS.h	913;"	d
configMIN	include/FreeRTOS.h	986;"	d
configNUM_THREAD_LOCAL_STORAGE_POINTERS	include/FreeRTOS.h	222;"	d
configPOST_SLEEP_PROCESSING	include/FreeRTOS.h	812;"	d
configPRECONDITION	include/FreeRTOS.h	274;"	d
configPRECONDITION_DEFINED	include/FreeRTOS.h	275;"	d
configPRECONDITION_DEFINED	include/FreeRTOS.h	277;"	d
configPRE_SLEEP_PROCESSING	include/FreeRTOS.h	808;"	d
configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING	include/FreeRTOS.h	804;"	d
configPRINTF	include/FreeRTOS.h	972;"	d
configQUEUE_REGISTRY_SIZE	include/FreeRTOS.h	326;"	d
configRECORD_STACK_HIGH_ADDRESS	include/FreeRTOS.h	436;"	d
configRUN_ADDITIONAL_TESTS	include/FreeRTOS.h	1060;"	d
configRUN_FREERTOS_SECURE_ONLY	include/FreeRTOS.h	1056;"	d
configSTACK_ALLOCATION_FROM_SEPARATE_HEAP	include/portable.h	90;"	d
configSTACK_DEPTH_TYPE	include/FreeRTOS.h	905;"	d
configSUPPORT_DYNAMIC_ALLOCATION	include/FreeRTOS.h	898;"	d
configSUPPORT_STATIC_ALLOCATION	include/FreeRTOS.h	893;"	d
configTASK_NOTIFICATION_ARRAY_ENTRIES	include/FreeRTOS.h	876;"	d
configTIMER_SERVICE_TASK_NAME	timers.c	66;"	d	file:
configUSE_ALTERNATIVE_API	include/FreeRTOS.h	242;"	d
configUSE_APPLICATION_TASK_TAG	include/FreeRTOS.h	218;"	d
configUSE_COUNTING_SEMAPHORES	include/FreeRTOS.h	238;"	d
configUSE_CO_ROUTINES	include/FreeRTOS.h	112;"	d
configUSE_DAEMON_TASK_STARTUP_HOOK	include/FreeRTOS.h	214;"	d
configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES	include/projdefs.h	60;"	d
configUSE_MALLOC_FAILED_HOOK	include/FreeRTOS.h	776;"	d
configUSE_MUTEXES	include/FreeRTOS.h	230;"	d
configUSE_NEWLIB_REENTRANT	include/FreeRTOS.h	69;"	d
configUSE_PORT_OPTIMISED_TASK_SELECTION	include/FreeRTOS.h	864;"	d
configUSE_POSIX_ERRNO	include/FreeRTOS.h	884;"	d
configUSE_QUEUE_SETS	include/FreeRTOS.h	816;"	d
configUSE_RECURSIVE_MUTEXES	include/FreeRTOS.h	226;"	d
configUSE_STATS_FORMATTING_FUNCTIONS	include/FreeRTOS.h	840;"	d
configUSE_TASK_FPU_SUPPORT	include/FreeRTOS.h	1032;"	d
configUSE_TASK_NOTIFICATIONS	include/FreeRTOS.h	872;"	d
configUSE_TICKLESS_IDLE	include/FreeRTOS.h	800;"	d
configUSE_TIMERS	include/FreeRTOS.h	234;"	d
configUSE_TIME_SLICING	include/FreeRTOS.h	832;"	d
configUSE_TRACE_FACILITY	include/FreeRTOS.h	848;"	d
corCoRoutineControlBlock	include/croutine.h	/^typedef struct corCoRoutineControlBlock$/;"	s
corCoRoutineControlBlock::pxCoRoutineFunction	include/croutine.h	/^    crCOROUTINE_CODE pxCoRoutineFunction;$/;"	m	struct:corCoRoutineControlBlock	access:public
corCoRoutineControlBlock::uxIndex	include/croutine.h	/^    UBaseType_t uxIndex;         \/*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
corCoRoutineControlBlock::uxPriority	include/croutine.h	/^    UBaseType_t uxPriority;      \/*< The priority of the co-routine in relation to other co-routines. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
corCoRoutineControlBlock::uxState	include/croutine.h	/^    uint16_t uxState;            \/*< Used internally by the co-routine implementation. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
corCoRoutineControlBlock::xEventListItem	include/croutine.h	/^    ListItem_t xEventListItem;   \/*< List item used to place the CRCB in event lists. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
corCoRoutineControlBlock::xGenericListItem	include/croutine.h	/^    ListItem_t xGenericListItem; \/*< List item used to place the CRCB in ready and blocked queues. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
corINITIAL_STATE	croutine.c	59;"	d	file:
crCOROUTINE_CODE	include/croutine.h	/^typedef void (* crCOROUTINE_CODE)( CoRoutineHandle_t,$/;"	t
crDELAY	include/croutine.h	310;"	d
crEND	include/croutine.h	249;"	d
crQUEUE_RECEIVE	include/croutine.h	496;"	d
crQUEUE_RECEIVE_FROM_ISR	include/croutine.h	723;"	d
crQUEUE_SEND	include/croutine.h	402;"	d
crQUEUE_SEND_FROM_ISR	include/croutine.h	607;"	d
crSET_STATE0	include/croutine.h	255;"	d
crSET_STATE1	include/croutine.h	258;"	d
crSTART	include/croutine.h	214;"	d
eAbortSleep	include/task.h	/^    eAbortSleep = 0,           \/* A task has been made ready or a context switch pended since portSUPPRESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. *\/$/;"	e	enum:__anon5
eBlocked	include/task.h	/^    eBlocked,         \/* The task being queried is in the Blocked state. *\/$/;"	e	enum:__anon3
eCurrentState	include/task.h	/^    eTaskState eCurrentState;                        \/* The state in which the task existed when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS	access:public
eDeleted	include/task.h	/^    eDeleted,         \/* The task being queried has been deleted, but its TCB has not yet been freed. *\/$/;"	e	enum:__anon3
eIncrement	include/task.h	/^    eIncrement,                   \/* Increment the task's notification value. *\/$/;"	e	enum:__anon4
eInvalid	include/task.h	/^    eInvalid          \/* Used as an 'invalid state' value. *\/$/;"	e	enum:__anon3
eNoAction	include/task.h	/^    eNoAction = 0,                \/* Notify the task without updating its notify value. *\/$/;"	e	enum:__anon4
eNoTasksWaitingTimeout	include/task.h	/^    eNoTasksWaitingTimeout     \/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. *\/$/;"	e	enum:__anon5
eNotifyAction	include/task.h	/^} eNotifyAction;$/;"	t	typeref:enum:__anon4
eReady	include/task.h	/^    eReady,           \/* The task being queried is in a ready or pending ready list. *\/$/;"	e	enum:__anon3
eRunning	include/task.h	/^    eRunning = 0,     \/* A task is querying the state of itself, so must be running. *\/$/;"	e	enum:__anon3
eSetBits	include/task.h	/^    eSetBits,                     \/* Set bits in the task's notification value. *\/$/;"	e	enum:__anon4
eSetValueWithOverwrite	include/task.h	/^    eSetValueWithOverwrite,       \/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. *\/$/;"	e	enum:__anon4
eSetValueWithoutOverwrite	include/task.h	/^    eSetValueWithoutOverwrite     \/* Set the task's notification value if the previous value has been read by the task. *\/$/;"	e	enum:__anon4
eSleepModeStatus	include/task.h	/^} eSleepModeStatus;$/;"	t	typeref:enum:__anon5
eStandardSleep	include/task.h	/^    eStandardSleep,            \/* Enter a sleep mode that will not last any longer than the expected idle time. *\/$/;"	e	enum:__anon5
eSuspended	include/task.h	/^    eSuspended,       \/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. *\/$/;"	e	enum:__anon3
eTaskConfirmSleepModeStatus	tasks.c	/^    eSleepModeStatus eTaskConfirmSleepModeStatus( void )$/;"	f	signature:( void )
eTaskGetState	include/mpu_wrappers.h	57;"	d
eTaskGetState	tasks.c	/^    eTaskState eTaskGetState( TaskHandle_t xTask )$/;"	f	signature:( TaskHandle_t xTask )
eTaskState	include/task.h	/^} eTaskState;$/;"	t	typeref:enum:__anon3
eTaskStateGet	include/FreeRTOS.h	990;"	d
errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	include/projdefs.h	54;"	d
errQUEUE_BLOCKED	include/projdefs.h	55;"	d
errQUEUE_EMPTY	include/projdefs.h	50;"	d
errQUEUE_FULL	include/projdefs.h	51;"	d
errQUEUE_YIELD	include/projdefs.h	56;"	d
ev	portable/ThirdParty/GCC/Posix/port.c	/^    struct event *ev;$/;"	m	struct:THREAD	typeref:struct:THREAD::event	file:	access:public
event	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^struct event$/;"	s	file:
event::cond	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^    pthread_cond_t cond;$/;"	m	struct:event	file:	access:public
event::event_triggered	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^    bool event_triggered;$/;"	m	struct:event	file:	access:public
event::mutex	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^    pthread_mutex_t mutex;$/;"	m	struct:event	file:	access:public
eventCLEAR_EVENTS_ON_EXIT_BIT	event_groups.c	53;"	d	file:
eventCLEAR_EVENTS_ON_EXIT_BIT	event_groups.c	58;"	d	file:
eventEVENT_BITS_CONTROL_BYTES	event_groups.c	56;"	d	file:
eventEVENT_BITS_CONTROL_BYTES	event_groups.c	61;"	d	file:
eventUNBLOCKED_DUE_TO_BIT_SET	event_groups.c	54;"	d	file:
eventUNBLOCKED_DUE_TO_BIT_SET	event_groups.c	59;"	d	file:
eventWAIT_FOR_ALL_BITS	event_groups.c	55;"	d	file:
eventWAIT_FOR_ALL_BITS	event_groups.c	60;"	d	file:
event_create	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^struct event * event_create()$/;"	f
event_create	portable/ThirdParty/GCC/Posix/utils/wait_for_event.h	/^struct event * event_create();$/;"	p	signature:()
event_delete	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^void event_delete( struct event * ev )$/;"	f	signature:( struct event * ev )
event_delete	portable/ThirdParty/GCC/Posix/utils/wait_for_event.h	/^void event_delete( struct event * );$/;"	p	signature:( struct event * )
event_signal	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^void event_signal( struct event * ev )$/;"	f	signature:( struct event * ev )
event_signal	portable/ThirdParty/GCC/Posix/utils/wait_for_event.h	/^void event_signal( struct event * ev );$/;"	p	signature:( struct event * ev )
event_triggered	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^    bool event_triggered;$/;"	m	struct:event	file:	access:public
event_wait	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^bool event_wait( struct event * ev )$/;"	f	signature:( struct event * ev )
event_wait	portable/ThirdParty/GCC/Posix/utils/wait_for_event.h	/^bool event_wait( struct event * ev );$/;"	p	signature:( struct event * ev )
event_wait_timed	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^bool event_wait_timed( struct event * ev,$/;"	f	signature:( struct event * ev, time_t ms )
event_wait_timed	portable/ThirdParty/GCC/Posix/utils/wait_for_event.h	/^bool event_wait_timed( struct event * ev,$/;"	p	signature:( struct event * ev, time_t ms )
freertos_tasks_c_additions_init	tasks.c	/^        static void freertos_tasks_c_additions_init( void )$/;"	f	file:	signature:( void )
hMainThread	portable/ThirdParty/GCC/Posix/port.c	/^static pthread_t hMainThread = ( pthread_t )NULL;$/;"	v	file:
hSigSetupThread	portable/ThirdParty/GCC/Posix/port.c	/^static pthread_once_t hSigSetupThread = PTHREAD_ONCE_INIT;$/;"	v	file:
heapBITS_PER_BYTE	portable/MemMang/heap_4.c	57;"	d	file:
heapBITS_PER_BYTE	portable/MemMang/heap_5.c	91;"	d	file:
heapMINIMUM_BLOCK_SIZE	portable/MemMang/heap_2.c	83;"	d	file:
heapMINIMUM_BLOCK_SIZE	portable/MemMang/heap_4.c	54;"	d	file:
heapMINIMUM_BLOCK_SIZE	portable/MemMang/heap_5.c	88;"	d	file:
heapSTRUCT_SIZE	portable/MemMang/heap_2.c	/^static const uint16_t heapSTRUCT_SIZE = ( ( sizeof( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );$/;"	v	file:
iDummy22	include/FreeRTOS.h	/^        int iDummy22;$/;"	m	struct:xSTATIC_TCB	access:public
iTaskErrno	tasks.c	/^        int iTaskErrno;$/;"	m	struct:tskTaskControlBlock	file:	access:public
listCURRENT_LIST_LENGTH	include/list.h	259;"	d
listFIRST_LIST_INTEGRITY_CHECK_VALUE	include/list.h	112;"	d
listFIRST_LIST_INTEGRITY_CHECK_VALUE	include/list.h	124;"	d
listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	110;"	d
listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	122;"	d
listGET_END_MARKER	include/list.h	245;"	d
listGET_HEAD_ENTRY	include/list.h	229;"	d
listGET_ITEM_VALUE_OF_HEAD_ENTRY	include/list.h	221;"	d
listGET_LIST_ITEM_OWNER	include/list.h	193;"	d
listGET_LIST_ITEM_VALUE	include/list.h	212;"	d
listGET_NEXT	include/list.h	237;"	d
listGET_OWNER_OF_HEAD_ENTRY	include/list.h	391;"	d
listGET_OWNER_OF_NEXT_ENTRY	include/list.h	281;"	d
listINSERT_END	include/list.h	350;"	d
listIS_CONTAINED_WITHIN	include/list.h	402;"	d
listLIST_IS_EMPTY	include/list.h	254;"	d
listLIST_IS_INITIALISED	include/list.h	417;"	d
listLIST_ITEM_CONTAINER	include/list.h	410;"	d
listREMOVE_ITEM	include/list.h	310;"	d
listSECOND_LIST_INTEGRITY_CHECK_VALUE	include/list.h	113;"	d
listSECOND_LIST_INTEGRITY_CHECK_VALUE	include/list.h	125;"	d
listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	111;"	d
listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	123;"	d
listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	114;"	d
listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	128;"	d
listSET_LIST_INTEGRITY_CHECK_1_VALUE	include/list.h	116;"	d
listSET_LIST_INTEGRITY_CHECK_1_VALUE	include/list.h	130;"	d
listSET_LIST_INTEGRITY_CHECK_2_VALUE	include/list.h	117;"	d
listSET_LIST_INTEGRITY_CHECK_2_VALUE	include/list.h	131;"	d
listSET_LIST_ITEM_OWNER	include/list.h	184;"	d
listSET_LIST_ITEM_VALUE	include/list.h	202;"	d
listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	115;"	d
listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	129;"	d
listTEST_LIST_INTEGRITY	include/list.h	119;"	d
listTEST_LIST_INTEGRITY	include/list.h	136;"	d
listTEST_LIST_ITEM_INTEGRITY	include/list.h	118;"	d
listTEST_LIST_ITEM_INTEGRITY	include/list.h	135;"	d
mtCOVERAGE_TEST_DELAY	include/FreeRTOS.h	856;"	d
mtCOVERAGE_TEST_MARKER	include/FreeRTOS.h	852;"	d
mutex	portable/ThirdParty/GCC/Posix/utils/wait_for_event.c	/^    pthread_mutex_t mutex;$/;"	m	struct:event	file:	access:public
pcHead	queue.c	/^    int8_t * pcHead;           \/*< Points to the beginning of the queue storage area. *\/$/;"	m	struct:QueueDefinition	file:	access:public
pcName	include/task.h	/^    const char * pcName;     \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_PARAMETERS	access:public
pcQueueGetName	include/FreeRTOS.h	332;"	d
pcQueueGetName	include/mpu_wrappers.h	118;"	d
pcQueueGetName	queue.c	/^    const char * pcQueueGetName( QueueHandle_t xQueue ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	signature:( QueueHandle_t xQueue )
pcQueueGetQueueName	include/FreeRTOS.h	1007;"	d
pcQueueName	queue.c	/^        const char * pcQueueName; \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:	access:public
pcReadFrom	queue.c	/^    int8_t * pcReadFrom; \/*< Points to the last place that a queued item was read from when the structure is used as a queue. *\/$/;"	m	struct:QueuePointers	file:	access:public
pcTail	queue.c	/^    int8_t * pcTail;     \/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. *\/$/;"	m	struct:QueuePointers	file:	access:public
pcTaskGetName	include/mpu_wrappers.h	66;"	d
pcTaskGetName	tasks.c	/^char * pcTaskGetName( TaskHandle_t xTaskToQuery ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	signature:( TaskHandle_t xTaskToQuery )
pcTaskGetTaskName	include/FreeRTOS.h	1005;"	d
pcTaskName	include/task.h	/^    const char * pcTaskName;                         \/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_STATUS	access:public
pcTaskName	tasks.c	/^    char pcTaskName[ configMAX_TASK_NAME_LEN ]; \/*< Descriptive name given to the task when created.  Facilitates debugging only. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
pcTimerGetName	include/mpu_wrappers.h	129;"	d
pcTimerGetName	timers.c	/^    const char * pcTimerGetName( TimerHandle_t xTimer ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	signature:( TimerHandle_t xTimer )
pcTimerGetTimerName	include/FreeRTOS.h	1006;"	d
pcTimerName	timers.c	/^        const char * pcTimerName;                   \/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
pcWriteTo	queue.c	/^    int8_t * pcWriteTo;        \/*< Points to the free next place in the storage area. *\/$/;"	m	struct:QueueDefinition	file:	access:public
pdBIG_ENDIAN	include/projdefs.h	119;"	d
pdFAIL	include/projdefs.h	49;"	d
pdFALSE	include/projdefs.h	45;"	d
pdFREERTOS_BIG_ENDIAN	include/projdefs.h	115;"	d
pdFREERTOS_ERRNO_EACCES	include/projdefs.h	80;"	d
pdFREERTOS_ERRNO_EADDRINUSE	include/projdefs.h	101;"	d
pdFREERTOS_ERRNO_EADDRNOTAVAIL	include/projdefs.h	105;"	d
pdFREERTOS_ERRNO_EAGAIN	include/projdefs.h	77;"	d
pdFREERTOS_ERRNO_EALREADY	include/projdefs.h	104;"	d
pdFREERTOS_ERRNO_EBADE	include/projdefs.h	93;"	d
pdFREERTOS_ERRNO_EBADF	include/projdefs.h	76;"	d
pdFREERTOS_ERRNO_EBUSY	include/projdefs.h	82;"	d
pdFREERTOS_ERRNO_ECANCELED	include/projdefs.h	110;"	d
pdFREERTOS_ERRNO_EEXIST	include/projdefs.h	83;"	d
pdFREERTOS_ERRNO_EFAULT	include/projdefs.h	81;"	d
pdFREERTOS_ERRNO_EFTYPE	include/projdefs.h	94;"	d
pdFREERTOS_ERRNO_EILSEQ	include/projdefs.h	109;"	d
pdFREERTOS_ERRNO_EINPROGRESS	include/projdefs.h	103;"	d
pdFREERTOS_ERRNO_EINTR	include/projdefs.h	73;"	d
pdFREERTOS_ERRNO_EINVAL	include/projdefs.h	88;"	d
pdFREERTOS_ERRNO_EIO	include/projdefs.h	74;"	d
pdFREERTOS_ERRNO_EISCONN	include/projdefs.h	106;"	d
pdFREERTOS_ERRNO_EISDIR	include/projdefs.h	87;"	d
pdFREERTOS_ERRNO_ENAMETOOLONG	include/projdefs.h	97;"	d
pdFREERTOS_ERRNO_ENMFILE	include/projdefs.h	95;"	d
pdFREERTOS_ERRNO_ENOBUFS	include/projdefs.h	99;"	d
pdFREERTOS_ERRNO_ENODEV	include/projdefs.h	85;"	d
pdFREERTOS_ERRNO_ENOENT	include/projdefs.h	72;"	d
pdFREERTOS_ERRNO_ENOMEDIUM	include/projdefs.h	108;"	d
pdFREERTOS_ERRNO_ENOMEM	include/projdefs.h	79;"	d
pdFREERTOS_ERRNO_ENOPROTOOPT	include/projdefs.h	100;"	d
pdFREERTOS_ERRNO_ENOSPC	include/projdefs.h	89;"	d
pdFREERTOS_ERRNO_ENOTCONN	include/projdefs.h	107;"	d
pdFREERTOS_ERRNO_ENOTDIR	include/projdefs.h	86;"	d
pdFREERTOS_ERRNO_ENOTEMPTY	include/projdefs.h	96;"	d
pdFREERTOS_ERRNO_ENXIO	include/projdefs.h	75;"	d
pdFREERTOS_ERRNO_EOPNOTSUPP	include/projdefs.h	98;"	d
pdFREERTOS_ERRNO_EROFS	include/projdefs.h	91;"	d
pdFREERTOS_ERRNO_ESPIPE	include/projdefs.h	90;"	d
pdFREERTOS_ERRNO_ETIMEDOUT	include/projdefs.h	102;"	d
pdFREERTOS_ERRNO_EUNATCH	include/projdefs.h	92;"	d
pdFREERTOS_ERRNO_EWOULDBLOCK	include/projdefs.h	78;"	d
pdFREERTOS_ERRNO_EXDEV	include/projdefs.h	84;"	d
pdFREERTOS_ERRNO_NONE	include/projdefs.h	71;"	d
pdFREERTOS_LITTLE_ENDIAN	include/projdefs.h	114;"	d
pdINTEGRITY_CHECK_VALUE	include/projdefs.h	64;"	d
pdINTEGRITY_CHECK_VALUE	include/projdefs.h	66;"	d
pdLITTLE_ENDIAN	include/projdefs.h	118;"	d
pdMS_TO_TICKS	include/projdefs.h	42;"	d
pdPASS	include/projdefs.h	48;"	d
pdTASK_CODE	include/FreeRTOS.h	1014;"	d
pdTASK_HOOK_CODE	include/FreeRTOS.h	1003;"	d
pdTRUE	include/projdefs.h	46;"	d
portALLOCATE_SECURE_CONTEXT	include/FreeRTOS.h	824;"	d
portARCH_NAME	include/portable.h	85;"	d
portASSERT_IF_INTERRUPT_PRIORITY_INVALID	include/FreeRTOS.h	844;"	d
portASSERT_IF_IN_ISR	include/FreeRTOS.h	860;"	d
portBASE_TYPE	portable/ThirdParty/GCC/Posix/portmacro.h	56;"	d
portBYTE_ALIGNMENT	portable/ThirdParty/GCC/Posix/portmacro.h	75;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	57;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	59;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	61;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	63;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	65;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	67;"	d
portCHAR	portable/ThirdParty/GCC/Posix/portmacro.h	50;"	d
portCLEAN_UP_TCB	include/FreeRTOS.h	314;"	d
portCLEAN_UP_TCB	portable/ThirdParty/GCC/Posix/portmacro.h	110;"	d
portCLEAR_INTERRUPT_MASK	portable/ThirdParty/GCC/Posix/portmacro.h	91;"	d
portCLEAR_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	310;"	d
portCLEAR_INTERRUPT_MASK_FROM_ISR	portable/ThirdParty/GCC/Posix/portmacro.h	99;"	d
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS	include/FreeRTOS.h	772;"	d
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS	portable/ThirdParty/GCC/Posix/portmacro.h	128;"	d
portCRITICAL_NESTING_IN_TCB	include/FreeRTOS.h	246;"	d
portDISABLE_INTERRUPTS	portable/ThirdParty/GCC/Posix/portmacro.h	100;"	d
portDONT_DISCARD	include/FreeRTOS.h	828;"	d
portDOUBLE	portable/ThirdParty/GCC/Posix/portmacro.h	52;"	d
portENABLE_INTERRUPTS	portable/ThirdParty/GCC/Posix/portmacro.h	101;"	d
portEND_SWITCHING_ISR	portable/ThirdParty/GCC/Posix/portmacro.h	83;"	d
portENTER_CRITICAL	portable/ThirdParty/GCC/Posix/portmacro.h	102;"	d
portEXIT_CRITICAL	portable/ThirdParty/GCC/Posix/portmacro.h	103;"	d
portFLOAT	portable/ThirdParty/GCC/Posix/portmacro.h	51;"	d
portFORCE_INLINE	include/atomic.h	87;"	d
portGET_RUN_TIME_COUNTER_VALUE	portable/ThirdParty/GCC/Posix/portmacro.h	129;"	d
portHAS_STACK_OVERFLOW_CHECKING	include/portable.h	81;"	d
portHAS_STACK_OVERFLOW_CHECKING	portable/ThirdParty/GCC/Posix/portmacro.h	72;"	d
portLONG	portable/ThirdParty/GCC/Posix/portmacro.h	53;"	d
portMAX_DELAY	portable/ThirdParty/GCC/Posix/portmacro.h	64;"	d
portMEMORY_BARRIER	include/FreeRTOS.h	281;"	d
portMEMORY_BARRIER	portable/ThirdParty/GCC/Posix/portmacro.h	125;"	d
portNUM_CONFIGURABLE_REGIONS	include/portable.h	77;"	d
portPOINTER_SIZE_TYPE	include/FreeRTOS.h	336;"	d
portPOINTER_SIZE_TYPE	portable/ThirdParty/GCC/Posix/portmacro.h	57;"	d
portPRE_TASK_DELETE_HOOK	include/FreeRTOS.h	318;"	d
portPRE_TASK_DELETE_HOOK	portable/ThirdParty/GCC/Posix/portmacro.h	109;"	d
portPRIVILEGE_BIT	include/FreeRTOS.h	780;"	d
portRESET_READY_PRIORITY	tasks.c	159;"	d	file:
portSETUP_TCB	include/FreeRTOS.h	322;"	d
portSET_INTERRUPT_MASK	portable/ThirdParty/GCC/Posix/portmacro.h	90;"	d
portSET_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	306;"	d
portSET_INTERRUPT_MASK_FROM_ISR	portable/ThirdParty/GCC/Posix/portmacro.h	98;"	d
portSHORT	portable/ThirdParty/GCC/Posix/portmacro.h	54;"	d
portSOFTWARE_BARRIER	include/FreeRTOS.h	285;"	d
portSTACK_GROWTH	portable/ThirdParty/GCC/Posix/portmacro.h	71;"	d
portSTACK_TYPE	portable/ThirdParty/GCC/Posix/portmacro.h	55;"	d
portSUPPRESS_TICKS_AND_SLEEP	include/FreeRTOS.h	788;"	d
portTASK_FUNCTION	portable/ThirdParty/GCC/Posix/portmacro.h	114;"	d
portTASK_FUNCTION	tasks.c	/^static portTASK_FUNCTION( prvIdleTask, pvParameters )$/;"	f	file:
portTASK_FUNCTION	timers.c	/^    static portTASK_FUNCTION( prvTimerTask, pvParameters )$/;"	f	file:
portTASK_FUNCTION_PROTO	portable/ThirdParty/GCC/Posix/portmacro.h	113;"	d
portTASK_FUNCTION_PROTO	tasks.c	/^static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;$/;"	p	file:
portTASK_FUNCTION_PROTO	timers.c	/^    static portTASK_FUNCTION_PROTO( prvTimerTask, pvParameters ) PRIVILEGED_FUNCTION;$/;"	p	file:
portTASK_USES_FLOATING_POINT	include/FreeRTOS.h	820;"	d
portTICK_PERIOD_MS	portable/ThirdParty/GCC/Posix/portmacro.h	73;"	d
portTICK_RATE_MICROSECONDS	portable/ThirdParty/GCC/Posix/portmacro.h	74;"	d
portTICK_RATE_MS	include/FreeRTOS.h	1004;"	d
portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	943;"	d
portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	951;"	d
portTICK_TYPE_ENTER_CRITICAL	include/FreeRTOS.h	940;"	d
portTICK_TYPE_ENTER_CRITICAL	include/FreeRTOS.h	948;"	d
portTICK_TYPE_EXIT_CRITICAL	include/FreeRTOS.h	941;"	d
portTICK_TYPE_EXIT_CRITICAL	include/FreeRTOS.h	949;"	d
portTICK_TYPE_IS_ATOMIC	include/FreeRTOS.h	888;"	d
portTICK_TYPE_IS_ATOMIC	portable/ThirdParty/GCC/Posix/portmacro.h	66;"	d
portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	942;"	d
portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	950;"	d
portTickType	include/FreeRTOS.h	991;"	d
portUSING_MPU_WRAPPERS	include/portable.h	73;"	d
portYIELD	portable/ThirdParty/GCC/Posix/portmacro.h	81;"	d
portYIELD_FROM_ISR	portable/ThirdParty/GCC/Posix/portmacro.h	84;"	d
portYIELD_WITHIN_API	include/FreeRTOS.h	784;"	d
prvAddCoRoutineToReadyQueue	croutine.c	68;"	d	file:
prvAddCurrentTaskToDelayedList	tasks.c	/^static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,$/;"	f	file:	signature:( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
prvAddNewTaskToReadyList	tasks.c	/^static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )$/;"	f	file:	signature:( TCB_t * pxNewTCB )
prvAddTaskToReadyList	tasks.c	221;"	d	file:
prvBytesInBuffer	stream_buffer.c	/^static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )$/;"	f	file:	signature:( const StreamBuffer_t * const pxStreamBuffer )
prvCheckDelayedList	croutine.c	/^    static void prvCheckDelayedList( void )$/;"	f	file:	signature:( void )
prvCheckDelayedList	croutine.c	/^    static void prvCheckDelayedList( void );$/;"	p	file:	signature:( void )
prvCheckForValidListAndQueue	timers.c	/^    static void prvCheckForValidListAndQueue( void )$/;"	f	file:	signature:( void )
prvCheckPendingReadyList	croutine.c	/^    static void prvCheckPendingReadyList( void )$/;"	f	file:	signature:( void )
prvCheckPendingReadyList	croutine.c	/^    static void prvCheckPendingReadyList( void );$/;"	p	file:	signature:( void )
prvCheckTasksWaitingTermination	tasks.c	/^static void prvCheckTasksWaitingTermination( void )$/;"	f	file:	signature:( void )
prvCopyDataFromQueue	queue.c	/^static void prvCopyDataFromQueue( Queue_t * const pxQueue,$/;"	f	file:	signature:( Queue_t * const pxQueue, void * const pvBuffer )
prvCopyDataToQueue	queue.c	/^static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,$/;"	f	file:	signature:( Queue_t * const pxQueue, const void * pvItemToQueue, const BaseType_t xPosition )
prvDeleteTCB	tasks.c	/^    static void prvDeleteTCB( TCB_t * pxTCB )$/;"	f	file:	signature:( TCB_t * pxTCB )
prvFatalError	portable/ThirdParty/GCC/Posix/port.c	/^static void prvFatalError( const char *pcCall, int iErrno )$/;"	f	file:	signature:( const char *pcCall, int iErrno )
prvGetDisinheritPriorityAfterTimeout	queue.c	/^    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )$/;"	f	file:	signature:( const Queue_t * const pxQueue )
prvGetExpectedIdleTime	tasks.c	/^    static TickType_t prvGetExpectedIdleTime( void )$/;"	f	file:	signature:( void )
prvGetNextExpireTime	timers.c	/^    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )$/;"	f	file:	signature:( BaseType_t * const pxListWasEmpty )
prvGetTCBFromHandle	tasks.c	234;"	d	file:
prvGetThreadFromTask	portable/ThirdParty/GCC/Posix/port.c	/^static inline Thread_t *prvGetThreadFromTask(TaskHandle_t xTask)$/;"	f	file:	signature:(TaskHandle_t xTask)
prvGetTimeNs	portable/ThirdParty/GCC/Posix/port.c	/^static uint64_t prvGetTimeNs(void)$/;"	f	file:	signature:(void)
prvHeapInit	portable/MemMang/heap_2.c	/^static void prvHeapInit( void )$/;"	f	file:	signature:( void )
prvHeapInit	portable/MemMang/heap_2.c	/^static void prvHeapInit( void );$/;"	p	file:	signature:( void )
prvHeapInit	portable/MemMang/heap_4.c	/^static void prvHeapInit( void ) \/* PRIVILEGED_FUNCTION *\/$/;"	f	file:	signature:( void )
prvInitialiseCoRoutineLists	croutine.c	/^    static void prvInitialiseCoRoutineLists( void )$/;"	f	file:	signature:( void )
prvInitialiseCoRoutineLists	croutine.c	/^    static void prvInitialiseCoRoutineLists( void );$/;"	p	file:	signature:( void )
prvInitialiseMutex	queue.c	/^    static void prvInitialiseMutex( Queue_t * pxNewQueue )$/;"	f	file:	signature:( Queue_t * pxNewQueue )
prvInitialiseNewQueue	queue.c	/^static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,$/;"	f	file:	signature:( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t * pucQueueStorage, const uint8_t ucQueueType, Queue_t * pxNewQueue )
prvInitialiseNewStreamBuffer	stream_buffer.c	/^static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,$/;"	f	file:	signature:( StreamBuffer_t * const pxStreamBuffer, uint8_t * const pucBuffer, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, uint8_t ucFlags )
prvInitialiseNewTask	tasks.c	/^static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,$/;"	f	file:	signature:( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, TCB_t * pxNewTCB, const MemoryRegion_t * const xRegions )
prvInitialiseNewTimer	timers.c	/^    static void prvInitialiseNewTimer( const char * const pcTimerName, \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	file:	signature:( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, Timer_t * pxNewTimer )
prvInitialiseTaskLists	tasks.c	/^static void prvInitialiseTaskLists( void )$/;"	f	file:	signature:( void )
prvInsertBlockIntoFreeList	portable/MemMang/heap_2.c	99;"	d	file:
prvInsertBlockIntoFreeList	portable/MemMang/heap_4.c	/^static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) \/* PRIVILEGED_FUNCTION *\/$/;"	f	file:	signature:( BlockLink_t * pxBlockToInsert )
prvInsertBlockIntoFreeList	portable/MemMang/heap_5.c	/^static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert )$/;"	f	file:	signature:( BlockLink_t * pxBlockToInsert )
prvInsertBlockIntoFreeList	portable/MemMang/heap_5.c	/^static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert );$/;"	p	file:	signature:( BlockLink_t * pxBlockToInsert )
prvInsertTimerInActiveList	timers.c	/^    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,$/;"	f	file:	signature:( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
prvIsQueueEmpty	queue.c	/^static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )$/;"	f	file:	signature:( const Queue_t * pxQueue )
prvIsQueueFull	queue.c	/^static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )$/;"	f	file:	signature:( const Queue_t * pxQueue )
prvListTasksWithinSingleList	tasks.c	/^    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,$/;"	f	file:	signature:( TaskStatus_t * pxTaskStatusArray, List_t * pxList, eTaskState eState )
prvLockQueue	queue.c	251;"	d	file:
prvNotifyQueueSetContainer	queue.c	/^    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )$/;"	f	file:	signature:( const Queue_t * const pxQueue )
prvProcessExpiredTimer	timers.c	/^    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,$/;"	f	file:	signature:( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
prvProcessReceivedCommands	timers.c	/^    static void prvProcessReceivedCommands( void )$/;"	f	file:	signature:( void )
prvProcessTimerOrBlockTask	timers.c	/^    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,$/;"	f	file:	signature:( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
prvReadBytesFromBuffer	stream_buffer.c	/^static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,$/;"	f	file:	signature:( StreamBuffer_t * pxStreamBuffer, uint8_t * pucData, size_t xCount, size_t xTail )
prvReadMessageFromBuffer	stream_buffer.c	/^static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,$/;"	f	file:	signature:( StreamBuffer_t * pxStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, size_t xBytesAvailable )
prvReloadTimer	timers.c	/^    static void prvReloadTimer( Timer_t * const pxTimer,$/;"	f	file:	signature:( Timer_t * const pxTimer, TickType_t xExpiredTime, const TickType_t xTimeNow )
prvResetNextTaskUnblockTime	tasks.c	/^static void prvResetNextTaskUnblockTime( void )$/;"	f	file:	signature:( void )
prvResumeThread	portable/ThirdParty/GCC/Posix/port.c	/^static void prvResumeThread( Thread_t * xThreadId );$/;"	p	file:	signature:( Thread_t * xThreadId )
prvResumeThread	portable/ThirdParty/GCC/Posix/port.c	/^static void prvResumeThread( Thread_t *xThreadId )$/;"	f	file:	signature:( Thread_t *xThreadId )
prvSampleTimeNow	timers.c	/^    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )$/;"	f	file:	signature:( BaseType_t * const pxTimerListsWereSwitched )
prvSearchForNameWithinSingleList	tasks.c	/^    static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,$/;"	f	file:	signature:( List_t * pxList, const char pcNameToQuery[] )
prvSetupSignalsAndSchedulerPolicy	portable/ThirdParty/GCC/Posix/port.c	/^static void prvSetupSignalsAndSchedulerPolicy( void )$/;"	f	file:	signature:( void )
prvSetupSignalsAndSchedulerPolicy	portable/ThirdParty/GCC/Posix/port.c	/^static void prvSetupSignalsAndSchedulerPolicy( void );$/;"	p	file:	signature:( void )
prvSetupTimerInterrupt	portable/ThirdParty/GCC/Posix/port.c	/^static void prvSetupTimerInterrupt( void );$/;"	p	file:	signature:( void )
prvSetupTimerInterrupt	portable/ThirdParty/GCC/Posix/port.c	/^void prvSetupTimerInterrupt( void )$/;"	f	signature:( void )
prvStartTimeNs	portable/ThirdParty/GCC/Posix/port.c	/^static uint64_t prvStartTimeNs;$/;"	v	file:
prvSuspendSelf	portable/ThirdParty/GCC/Posix/port.c	/^static void prvSuspendSelf( Thread_t * thread);$/;"	p	file:	signature:( Thread_t * thread)
prvSuspendSelf	portable/ThirdParty/GCC/Posix/port.c	/^static void prvSuspendSelf( Thread_t *thread )$/;"	f	file:	signature:( Thread_t *thread )
prvSwitchThread	portable/ThirdParty/GCC/Posix/port.c	/^static void prvSwitchThread( Thread_t * xThreadToResume,$/;"	p	file:	signature:( Thread_t * xThreadToResume, Thread_t *xThreadToSuspend )
prvSwitchThread	portable/ThirdParty/GCC/Posix/port.c	/^static void prvSwitchThread( Thread_t *pxThreadToResume,$/;"	f	file:	signature:( Thread_t *pxThreadToResume, Thread_t *pxThreadToSuspend )
prvSwitchTimerLists	timers.c	/^    static void prvSwitchTimerLists( void )$/;"	f	file:	signature:( void )
prvTaskCheckFreeStackSpace	tasks.c	/^    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )$/;"	f	file:	signature:( const uint8_t * pucStackByte )
prvTaskIsTaskSuspended	tasks.c	/^    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )$/;"	f	file:	signature:( const TaskHandle_t xTask )
prvTestWaitCondition	event_groups.c	/^static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,$/;"	f	file:	signature:( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
prvUnlockQueue	queue.c	/^static void prvUnlockQueue( Queue_t * const pxQueue )$/;"	f	file:	signature:( Queue_t * const pxQueue )
prvWaitForStart	portable/ThirdParty/GCC/Posix/port.c	/^static void *prvWaitForStart( void * pvParams )$/;"	f	file:	signature:( void * pvParams )
prvWaitForStart	portable/ThirdParty/GCC/Posix/port.c	/^static void *prvWaitForStart( void * pvParams );$/;"	p	file:	signature:( void * pvParams )
prvWriteBytesToBuffer	stream_buffer.c	/^static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,$/;"	f	file:	signature:( StreamBuffer_t * const pxStreamBuffer, const uint8_t * pucData, size_t xCount, size_t xHead )
prvWriteMessageToBuffer	stream_buffer.c	/^static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,$/;"	f	file:	signature:( StreamBuffer_t * const pxStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, size_t xSpace, size_t xRequiredSpace )
prvWriteNameToBuffer	tasks.c	/^    static char * prvWriteNameToBuffer( char * pcBuffer,$/;"	f	file:	signature:( char * pcBuffer, const char * pcTaskName )
pthread	portable/ThirdParty/GCC/Posix/port.c	/^    pthread_t pthread;$/;"	m	struct:THREAD	file:	access:public
pucBuffer	stream_buffer.c	/^    uint8_t * pucBuffer;                         \/* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
pucStartAddress	include/portable.h	/^    uint8_t * pucStartAddress;$/;"	m	struct:HeapRegion	access:public
puxStackBuffer	include/task.h	/^    StackType_t * puxStackBuffer;$/;"	m	struct:xTASK_PARAMETERS	access:public
pvBaseAddress	include/task.h	/^    void * pvBaseAddress;$/;"	m	struct:xMEMORY_REGION	access:public
pvDummy1	include/FreeRTOS.h	/^    void * pvDummy1;$/;"	m	struct:xSTATIC_TIMER	access:public
pvDummy1	include/FreeRTOS.h	/^    void * pvDummy1[ 3 ];$/;"	m	struct:xSTATIC_QUEUE	access:public
pvDummy15	include/FreeRTOS.h	/^        void * pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];$/;"	m	struct:xSTATIC_TCB	access:public
pvDummy2	include/FreeRTOS.h	/^        void * pvDummy2;$/;"	m	union:xSTATIC_QUEUE::__anon6	access:public
pvDummy2	include/FreeRTOS.h	/^    void * pvDummy2[ 3 ];$/;"	m	struct:xSTATIC_STREAM_BUFFER	access:public
pvDummy3	include/FreeRTOS.h	/^    void * pvDummy3;$/;"	m	struct:xSTATIC_LIST	access:public
pvDummy3	include/FreeRTOS.h	/^    void * pvDummy3[ 2 ];$/;"	m	struct:xSTATIC_MINI_LIST_ITEM	access:public
pvDummy3	include/FreeRTOS.h	/^    void * pvDummy3[ 4 ];$/;"	m	struct:xSTATIC_LIST_ITEM	access:public
pvDummy5	include/FreeRTOS.h	/^    void * pvDummy5;$/;"	m	struct:xSTATIC_TIMER	access:public
pvDummy6	include/FreeRTOS.h	/^    TaskFunction_t pvDummy6;$/;"	m	struct:xSTATIC_TIMER	access:public
pvDummy7	include/FreeRTOS.h	/^        void * pvDummy7;$/;"	m	struct:xSTATIC_QUEUE	access:public
pvOwner	include/list.h	/^    void * pvOwner;                                     \/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. *\/$/;"	m	struct:xLIST_ITEM	access:public
pvParameter1	timers.c	/^        void * pvParameter1;                 \/* << The value that will be used as the callback functions first parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:	access:public
pvParameters	include/task.h	/^    void * pvParameters;$/;"	m	struct:xTASK_PARAMETERS	access:public
pvParams	portable/ThirdParty/GCC/Posix/port.c	/^    void *pvParams;$/;"	m	struct:THREAD	file:	access:public
pvPortMalloc	portable/MemMang/heap_1.c	/^void * pvPortMalloc( size_t xWantedSize )$/;"	f	signature:( size_t xWantedSize )
pvPortMalloc	portable/MemMang/heap_2.c	/^void * pvPortMalloc( size_t xWantedSize )$/;"	f	signature:( size_t xWantedSize )
pvPortMalloc	portable/MemMang/heap_3.c	/^void * pvPortMalloc( size_t xWantedSize )$/;"	f	signature:( size_t xWantedSize )
pvPortMalloc	portable/MemMang/heap_4.c	/^void * pvPortMalloc( size_t xWantedSize )$/;"	f	signature:( size_t xWantedSize )
pvPortMalloc	portable/MemMang/heap_5.c	/^void * pvPortMalloc( size_t xWantedSize )$/;"	f	signature:( size_t xWantedSize )
pvPortMallocStack	include/portable.h	185;"	d
pvTaskCode	include/task.h	/^    TaskFunction_t pvTaskCode;$/;"	m	struct:xTASK_PARAMETERS	access:public
pvTaskGetThreadLocalStoragePointer	include/mpu_wrappers.h	73;"	d
pvTaskGetThreadLocalStoragePointer	tasks.c	/^    void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,$/;"	f	signature:( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
pvTaskIncrementMutexHeldCount	tasks.c	/^    TaskHandle_t pvTaskIncrementMutexHeldCount( void )$/;"	f	signature:( void )
pvThreadLocalStoragePointers	tasks.c	/^        void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];$/;"	m	struct:tskTaskControlBlock	file:	access:public
pvTimerGetTimerID	include/mpu_wrappers.h	124;"	d
pvTimerGetTimerID	timers.c	/^    void * pvTimerGetTimerID( const TimerHandle_t xTimer )$/;"	f	signature:( const TimerHandle_t xTimer )
pvTimerID	timers.c	/^        void * pvTimerID;                           \/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
pxCallbackFunction	timers.c	/^        PendedFunction_t pxCallbackFunction; \/* << The callback function to execute. *\/$/;"	m	struct:tmrCallbackParameters	file:	access:public
pxCallbackFunction	timers.c	/^        TimerCallbackFunction_t pxCallbackFunction; \/*<< The function that will be called when the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
pxCoRoutineFunction	include/croutine.h	/^    crCOROUTINE_CODE pxCoRoutineFunction;$/;"	m	struct:corCoRoutineControlBlock	access:public
pxCode	portable/ThirdParty/GCC/Posix/port.c	/^    pdTASK_CODE pxCode;$/;"	m	struct:THREAD	file:	access:public
pxContainer	include/FreeRTOS.h	1020;"	d
pxContainer	include/list.h	/^    struct xLIST * configLIST_VOLATILE pxContainer;     \/*< Pointer to the list in which this list item is placed (if any). *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE	access:public
pxCurrentCoRoutine	croutine.c	/^    CRCB_t * pxCurrentCoRoutine = NULL;$/;"	v
pxCurrentTCB	tasks.c	/^PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;$/;"	v
pxCurrentTimerList	timers.c	/^    PRIVILEGED_DATA static List_t * pxCurrentTimerList;$/;"	v	file:
pxDelayedCoRoutineList	croutine.c	/^    static List_t * pxDelayedCoRoutineList = NULL;                          \/*< Points to the delayed co-routine list currently being used. *\/$/;"	v	file:
pxDelayedTaskList	tasks.c	/^PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;              \/*< Points to the delayed task list currently being used. *\/$/;"	v	file:
pxDummy1	include/FreeRTOS.h	/^    void * pxDummy1;$/;"	m	struct:xSTATIC_TCB	access:public
pxDummy14	include/FreeRTOS.h	/^        void * pxDummy14;$/;"	m	struct:xSTATIC_TCB	access:public
pxDummy6	include/FreeRTOS.h	/^    void * pxDummy6;$/;"	m	struct:xSTATIC_TCB	access:public
pxDummy8	include/FreeRTOS.h	/^        void * pxDummy8;$/;"	m	struct:xSTATIC_TCB	access:public
pxEnd	portable/MemMang/heap_4.c	/^PRIVILEGED_DATA static BlockLink_t xStart, * pxEnd = NULL;$/;"	v	file:
pxEnd	portable/MemMang/heap_5.c	/^static BlockLink_t xStart, * pxEnd = NULL;$/;"	v	file:
pxEndOfStack	tasks.c	/^        StackType_t * pxEndOfStack; \/*< Points to the highest valid address for the stack. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
pxISR	include/deprecated_definitions.h	/^    typedef void ( __interrupt __far * pxISR )();$/;"	t
pxIndex	include/list.h	/^    ListItem_t * configLIST_VOLATILE pxIndex; \/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). *\/$/;"	m	struct:xLIST	access:public
pxNext	include/list.h	/^    struct xLIST_ITEM * configLIST_VOLATILE pxNext;     \/*< Pointer to the next ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE	access:public
pxNext	include/list.h	/^    struct xLIST_ITEM * configLIST_VOLATILE pxNext;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE	access:public
pxNextFreeBlock	portable/MemMang/heap_2.c	/^    struct A_BLOCK_LINK * pxNextFreeBlock; \/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:	access:public
pxNextFreeBlock	portable/MemMang/heap_4.c	/^    struct A_BLOCK_LINK * pxNextFreeBlock; \/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:	access:public
pxNextFreeBlock	portable/MemMang/heap_5.c	/^    struct A_BLOCK_LINK * pxNextFreeBlock; \/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:	access:public
pxOverflowDelayedCoRoutineList	croutine.c	/^    static List_t * pxOverflowDelayedCoRoutineList = NULL;                  \/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. *\/$/;"	v	file:
pxOverflowDelayedTaskList	tasks.c	/^PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;      \/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. *\/$/;"	v	file:
pxOverflowTimerList	timers.c	/^    PRIVILEGED_DATA static List_t * pxOverflowTimerList;$/;"	v	file:
pxPortInitialiseStack	portable/ThirdParty/GCC/Posix/port.c	/^portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack,$/;"	f	signature:( portSTACK_TYPE *pxTopOfStack, portSTACK_TYPE *pxEndOfStack, pdTASK_CODE pxCode, void *pvParameters )
pxPrevious	include/list.h	/^    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; \/*< Pointer to the previous ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE	access:public
pxPrevious	include/list.h	/^    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE	access:public
pxQueueSetContainer	queue.c	/^        struct QueueDefinition * pxQueueSetContainer;$/;"	m	struct:QueueDefinition	typeref:struct:QueueDefinition::QueueDefinition	file:	access:public
pxReadyCoRoutineLists	croutine.c	/^    static List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ]; \/*< Prioritised ready co-routines. *\/$/;"	v	file:
pxReadyTasksLists	tasks.c	/^PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; \/*< Prioritised ready tasks. *\/$/;"	v	file:
pxStack	tasks.c	/^    StackType_t * pxStack;                      \/*< Points to the start of the stack. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
pxStackBase	include/task.h	/^    StackType_t * pxStackBase;                       \/* Points to the lowest address of the task's stack area. *\/$/;"	m	struct:xTASK_STATUS	access:public
pxTaskBuffer	include/task.h	/^        StaticTask_t * const pxTaskBuffer;$/;"	m	struct:xTASK_PARAMETERS	access:public
pxTaskTag	tasks.c	/^        TaskHookFunction_t pxTaskTag;$/;"	m	struct:tskTaskControlBlock	file:	access:public
pxTimer	timers.c	/^        Timer_t * pxTimer;        \/*<< The timer to which the command will be applied. *\/$/;"	m	struct:tmrTimerParameters	file:	access:public
pxTopOfStack	tasks.c	/^    volatile StackType_t * pxTopOfStack; \/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
queueINT8_MAX	queue.c	55;"	d	file:
queueLOCKED_UNMODIFIED	queue.c	54;"	d	file:
queueMUTEX_GIVE_BLOCK_TIME	queue.c	84;"	d	file:
queueOVERWRITE	include/queue.h	70;"	d
queueQUEUE_IS_MUTEX	queue.c	67;"	d	file:
queueQUEUE_TYPE_BASE	include/queue.h	73;"	d
queueQUEUE_TYPE_BINARY_SEMAPHORE	include/queue.h	77;"	d
queueQUEUE_TYPE_COUNTING_SEMAPHORE	include/queue.h	76;"	d
queueQUEUE_TYPE_MUTEX	include/queue.h	75;"	d
queueQUEUE_TYPE_RECURSIVE_MUTEX	include/queue.h	78;"	d
queueQUEUE_TYPE_SET	include/queue.h	74;"	d
queueSEMAPHORE_QUEUE_ITEM_LENGTH	queue.c	83;"	d	file:
queueSEND_TO_BACK	include/queue.h	68;"	d
queueSEND_TO_FRONT	include/queue.h	69;"	d
queueUNLOCKED	queue.c	53;"	d	file:
queueYIELD_IF_USING_PREEMPTION	queue.c	90;"	d	file:
queueYIELD_IF_USING_PREEMPTION	queue.c	92;"	d	file:
sbBYTES_TO_STORE_MESSAGE_LENGTH	stream_buffer.c	133;"	d	file:
sbFLAGS_IS_MESSAGE_BUFFER	stream_buffer.c	136;"	d	file:
sbFLAGS_IS_STATICALLY_ALLOCATED	stream_buffer.c	137;"	d	file:
sbRECEIVE_COMPLETED	stream_buffer.c	58;"	d	file:
sbRECEIVE_COMPLETED_FROM_ISR	stream_buffer.c	73;"	d	file:
sbSEND_COMPLETED	stream_buffer.c	97;"	d	file:
sbSEND_COMPLETE_FROM_ISR	stream_buffer.c	112;"	d	file:
semBINARY_SEMAPHORE_QUEUE_LENGTH	include/semphr.h	40;"	d
semGIVE_BLOCK_TIME	include/semphr.h	42;"	d
semSEMAPHORE_QUEUE_ITEM_LENGTH	include/semphr.h	41;"	d
static	croutine.c	41;"	d	file:
static	tasks.c	109;"	d	file:
taskCHECK_FOR_STACK_OVERFLOW	include/stack_macros.h	100;"	d
taskCHECK_FOR_STACK_OVERFLOW	include/stack_macros.h	124;"	d
taskCHECK_FOR_STACK_OVERFLOW	include/stack_macros.h	51;"	d
taskCHECK_FOR_STACK_OVERFLOW	include/stack_macros.h	66;"	d
taskCHECK_FOR_STACK_OVERFLOW	include/stack_macros.h	81;"	d
taskDISABLE_INTERRUPTS	include/task.h	230;"	d
taskENABLE_INTERRUPTS	include/task.h	240;"	d
taskENTER_CRITICAL	include/task.h	204;"	d
taskENTER_CRITICAL_FROM_ISR	include/task.h	205;"	d
taskEVENT_LIST_ITEM_VALUE_IN_USE	tasks.c	245;"	d	file:
taskEVENT_LIST_ITEM_VALUE_IN_USE	tasks.c	247;"	d	file:
taskEXIT_CRITICAL	include/task.h	219;"	d
taskEXIT_CRITICAL_FROM_ISR	include/task.h	220;"	d
taskNOTIFICATION_RECEIVED	tasks.c	73;"	d	file:
taskNOT_WAITING_NOTIFICATION	tasks.c	71;"	d	file:
taskRECORD_READY_PRIORITY	tasks.c	126;"	d	file:
taskRECORD_READY_PRIORITY	tasks.c	168;"	d	file:
taskRESET_READY_PRIORITY	tasks.c	158;"	d	file:
taskRESET_READY_PRIORITY	tasks.c	187;"	d	file:
taskSCHEDULER_NOT_STARTED	include/task.h	246;"	d
taskSCHEDULER_RUNNING	include/task.h	247;"	d
taskSCHEDULER_SUSPENDED	include/task.h	245;"	d
taskSELECT_HIGHEST_PRIORITY_TASK	tasks.c	136;"	d	file:
taskSELECT_HIGHEST_PRIORITY_TASK	tasks.c	172;"	d	file:
taskSWITCH_DELAYED_LISTS	tasks.c	201;"	d	file:
taskWAITING_NOTIFICATION	tasks.c	72;"	d	file:
taskYIELD	include/task.h	190;"	d
taskYIELD_IF_USING_PREEMPTION	tasks.c	65;"	d	file:
taskYIELD_IF_USING_PREEMPTION	tasks.c	67;"	d	file:
tmrCOMMAND_CHANGE_PERIOD	include/timers.h	63;"	d
tmrCOMMAND_CHANGE_PERIOD_FROM_ISR	include/timers.h	70;"	d
tmrCOMMAND_DELETE	include/timers.h	64;"	d
tmrCOMMAND_EXECUTE_CALLBACK	include/timers.h	58;"	d
tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR	include/timers.h	57;"	d
tmrCOMMAND_RESET	include/timers.h	61;"	d
tmrCOMMAND_RESET_FROM_ISR	include/timers.h	68;"	d
tmrCOMMAND_START	include/timers.h	60;"	d
tmrCOMMAND_START_DONT_TRACE	include/timers.h	59;"	d
tmrCOMMAND_START_FROM_ISR	include/timers.h	67;"	d
tmrCOMMAND_STOP	include/timers.h	62;"	d
tmrCOMMAND_STOP_FROM_ISR	include/timers.h	69;"	d
tmrCallbackParameters	timers.c	/^    typedef struct tmrCallbackParameters$/;"	s	file:
tmrCallbackParameters::pvParameter1	timers.c	/^        void * pvParameter1;                 \/* << The value that will be used as the callback functions first parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:	access:public
tmrCallbackParameters::pxCallbackFunction	timers.c	/^        PendedFunction_t pxCallbackFunction; \/* << The callback function to execute. *\/$/;"	m	struct:tmrCallbackParameters	file:	access:public
tmrCallbackParameters::ulParameter2	timers.c	/^        uint32_t ulParameter2;               \/* << The value that will be used as the callback functions second parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:	access:public
tmrFIRST_FROM_ISR_COMMAND	include/timers.h	66;"	d
tmrMAX_TIME_BEFORE_OVERFLOW	timers.c	61;"	d	file:
tmrNO_DELAY	timers.c	60;"	d	file:
tmrSTATUS_IS_ACTIVE	timers.c	70;"	d	file:
tmrSTATUS_IS_AUTORELOAD	timers.c	72;"	d	file:
tmrSTATUS_IS_STATICALLY_ALLOCATED	timers.c	71;"	d	file:
tmrTIMER_CALLBACK	include/FreeRTOS.h	1013;"	d
tmrTimerControl	timers.c	/^    typedef struct tmrTimerControl                  \/* The old naming convention is used to prevent breaking kernel aware debuggers. *\/$/;"	s	file:
tmrTimerControl::pcTimerName	timers.c	/^        const char * pcTimerName;                   \/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
tmrTimerControl::pvTimerID	timers.c	/^        void * pvTimerID;                           \/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
tmrTimerControl::pxCallbackFunction	timers.c	/^        TimerCallbackFunction_t pxCallbackFunction; \/*<< The function that will be called when the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
tmrTimerControl::ucStatus	timers.c	/^        uint8_t ucStatus;                           \/*<< Holds bits to say if the timer was statically allocated or not, and if it is active or not. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
tmrTimerControl::uxTimerNumber	timers.c	/^            UBaseType_t uxTimerNumber;              \/*<< An ID assigned by trace tools such as FreeRTOS+Trace *\/$/;"	m	struct:tmrTimerControl	file:	access:public
tmrTimerControl::xTimerListItem	timers.c	/^        ListItem_t xTimerListItem;                  \/*<< Standard linked list item as used by all kernel features for event management. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
tmrTimerControl::xTimerPeriodInTicks	timers.c	/^        TickType_t xTimerPeriodInTicks;             \/*<< How quickly and often the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
tmrTimerParameters	timers.c	/^    typedef struct tmrTimerParameters$/;"	s	file:
tmrTimerParameters::pxTimer	timers.c	/^        Timer_t * pxTimer;        \/*<< The timer to which the command will be applied. *\/$/;"	m	struct:tmrTimerParameters	file:	access:public
tmrTimerParameters::xMessageValue	timers.c	/^        TickType_t xMessageValue; \/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. *\/$/;"	m	struct:tmrTimerParameters	file:	access:public
tmrTimerQueueMessage	timers.c	/^    typedef struct tmrTimerQueueMessage$/;"	s	file:
tmrTimerQueueMessage::__anon1::xCallbackParameters	timers.c	/^                CallbackParameters_t xCallbackParameters;$/;"	m	union:tmrTimerQueueMessage::__anon1	file:	access:public
tmrTimerQueueMessage::__anon1::xTimerParameters	timers.c	/^            TimerParameter_t xTimerParameters;$/;"	m	union:tmrTimerQueueMessage::__anon1	file:	access:public
tmrTimerQueueMessage::u	timers.c	/^        } u;$/;"	m	struct:tmrTimerQueueMessage	typeref:union:tmrTimerQueueMessage::__anon1	file:	access:public
tmrTimerQueueMessage::xMessageID	timers.c	/^        BaseType_t xMessageID; \/*<< The command being sent to the timer service task. *\/$/;"	m	struct:tmrTimerQueueMessage	file:	access:public
traceBLOCKING_ON_QUEUE_PEEK	include/FreeRTOS.h	419;"	d
traceBLOCKING_ON_QUEUE_RECEIVE	include/FreeRTOS.h	410;"	d
traceBLOCKING_ON_QUEUE_SEND	include/FreeRTOS.h	428;"	d
traceBLOCKING_ON_STREAM_BUFFER_RECEIVE	include/FreeRTOS.h	738;"	d
traceBLOCKING_ON_STREAM_BUFFER_SEND	include/FreeRTOS.h	722;"	d
traceCREATE_COUNTING_SEMAPHORE	include/FreeRTOS.h	486;"	d
traceCREATE_COUNTING_SEMAPHORE_FAILED	include/FreeRTOS.h	490;"	d
traceCREATE_MUTEX	include/FreeRTOS.h	462;"	d
traceCREATE_MUTEX_FAILED	include/FreeRTOS.h	466;"	d
traceEND	include/FreeRTOS.h	351;"	d
traceEVENT_GROUP_CLEAR_BITS	include/FreeRTOS.h	642;"	d
traceEVENT_GROUP_CLEAR_BITS_FROM_ISR	include/FreeRTOS.h	646;"	d
traceEVENT_GROUP_CREATE	include/FreeRTOS.h	618;"	d
traceEVENT_GROUP_CREATE_FAILED	include/FreeRTOS.h	622;"	d
traceEVENT_GROUP_DELETE	include/FreeRTOS.h	658;"	d
traceEVENT_GROUP_SET_BITS	include/FreeRTOS.h	650;"	d
traceEVENT_GROUP_SET_BITS_FROM_ISR	include/FreeRTOS.h	654;"	d
traceEVENT_GROUP_SYNC_BLOCK	include/FreeRTOS.h	626;"	d
traceEVENT_GROUP_SYNC_END	include/FreeRTOS.h	630;"	d
traceEVENT_GROUP_WAIT_BITS_BLOCK	include/FreeRTOS.h	634;"	d
traceEVENT_GROUP_WAIT_BITS_END	include/FreeRTOS.h	638;"	d
traceFREE	include/FreeRTOS.h	614;"	d
traceGIVE_MUTEX_RECURSIVE	include/FreeRTOS.h	470;"	d
traceGIVE_MUTEX_RECURSIVE_FAILED	include/FreeRTOS.h	474;"	d
traceINCREASE_TICK_COUNT	include/FreeRTOS.h	365;"	d
traceLOW_POWER_IDLE_BEGIN	include/FreeRTOS.h	370;"	d
traceLOW_POWER_IDLE_END	include/FreeRTOS.h	375;"	d
traceMALLOC	include/FreeRTOS.h	610;"	d
traceMOVED_TASK_TO_READY_STATE	include/FreeRTOS.h	446;"	d
tracePEND_FUNC_CALL	include/FreeRTOS.h	662;"	d
tracePEND_FUNC_CALL_FROM_ISR	include/FreeRTOS.h	666;"	d
tracePOST_MOVED_TASK_TO_READY_STATE	include/FreeRTOS.h	450;"	d
traceQUEUE_CREATE	include/FreeRTOS.h	454;"	d
traceQUEUE_CREATE_FAILED	include/FreeRTOS.h	458;"	d
traceQUEUE_DELETE	include/FreeRTOS.h	546;"	d
traceQUEUE_PEEK	include/FreeRTOS.h	510;"	d
traceQUEUE_PEEK_FAILED	include/FreeRTOS.h	514;"	d
traceQUEUE_PEEK_FROM_ISR	include/FreeRTOS.h	518;"	d
traceQUEUE_PEEK_FROM_ISR_FAILED	include/FreeRTOS.h	542;"	d
traceQUEUE_RECEIVE	include/FreeRTOS.h	506;"	d
traceQUEUE_RECEIVE_FAILED	include/FreeRTOS.h	522;"	d
traceQUEUE_RECEIVE_FROM_ISR	include/FreeRTOS.h	534;"	d
traceQUEUE_RECEIVE_FROM_ISR_FAILED	include/FreeRTOS.h	538;"	d
traceQUEUE_REGISTRY_ADD	include/FreeRTOS.h	670;"	d
traceQUEUE_SEND	include/FreeRTOS.h	498;"	d
traceQUEUE_SEND_FAILED	include/FreeRTOS.h	502;"	d
traceQUEUE_SEND_FROM_ISR	include/FreeRTOS.h	526;"	d
traceQUEUE_SEND_FROM_ISR_FAILED	include/FreeRTOS.h	530;"	d
traceQUEUE_SET_SEND	include/FreeRTOS.h	494;"	d
traceSTART	include/FreeRTOS.h	344;"	d
traceSTREAM_BUFFER_CREATE	include/FreeRTOS.h	710;"	d
traceSTREAM_BUFFER_CREATE_FAILED	include/FreeRTOS.h	702;"	d
traceSTREAM_BUFFER_CREATE_STATIC_FAILED	include/FreeRTOS.h	706;"	d
traceSTREAM_BUFFER_DELETE	include/FreeRTOS.h	714;"	d
traceSTREAM_BUFFER_RECEIVE	include/FreeRTOS.h	742;"	d
traceSTREAM_BUFFER_RECEIVE_FAILED	include/FreeRTOS.h	746;"	d
traceSTREAM_BUFFER_RECEIVE_FROM_ISR	include/FreeRTOS.h	750;"	d
traceSTREAM_BUFFER_RESET	include/FreeRTOS.h	718;"	d
traceSTREAM_BUFFER_SEND	include/FreeRTOS.h	726;"	d
traceSTREAM_BUFFER_SEND_FAILED	include/FreeRTOS.h	730;"	d
traceSTREAM_BUFFER_SEND_FROM_ISR	include/FreeRTOS.h	734;"	d
traceTAKE_MUTEX_RECURSIVE	include/FreeRTOS.h	478;"	d
traceTAKE_MUTEX_RECURSIVE_FAILED	include/FreeRTOS.h	482;"	d
traceTASK_CREATE	include/FreeRTOS.h	550;"	d
traceTASK_CREATE_FAILED	include/FreeRTOS.h	554;"	d
traceTASK_DELAY	include/FreeRTOS.h	566;"	d
traceTASK_DELAY_UNTIL	include/FreeRTOS.h	562;"	d
traceTASK_DELETE	include/FreeRTOS.h	558;"	d
traceTASK_INCREMENT_TICK	include/FreeRTOS.h	586;"	d
traceTASK_NOTIFY	include/FreeRTOS.h	690;"	d
traceTASK_NOTIFY_FROM_ISR	include/FreeRTOS.h	694;"	d
traceTASK_NOTIFY_GIVE_FROM_ISR	include/FreeRTOS.h	698;"	d
traceTASK_NOTIFY_TAKE	include/FreeRTOS.h	678;"	d
traceTASK_NOTIFY_TAKE_BLOCK	include/FreeRTOS.h	674;"	d
traceTASK_NOTIFY_WAIT	include/FreeRTOS.h	686;"	d
traceTASK_NOTIFY_WAIT_BLOCK	include/FreeRTOS.h	682;"	d
traceTASK_PRIORITY_DISINHERIT	include/FreeRTOS.h	401;"	d
traceTASK_PRIORITY_INHERIT	include/FreeRTOS.h	392;"	d
traceTASK_PRIORITY_SET	include/FreeRTOS.h	570;"	d
traceTASK_RESUME	include/FreeRTOS.h	578;"	d
traceTASK_RESUME_FROM_ISR	include/FreeRTOS.h	582;"	d
traceTASK_SUSPEND	include/FreeRTOS.h	574;"	d
traceTASK_SWITCHED_IN	include/FreeRTOS.h	358;"	d
traceTASK_SWITCHED_OUT	include/FreeRTOS.h	382;"	d
traceTIMER_COMMAND_RECEIVED	include/FreeRTOS.h	606;"	d
traceTIMER_COMMAND_SEND	include/FreeRTOS.h	598;"	d
traceTIMER_CREATE	include/FreeRTOS.h	590;"	d
traceTIMER_CREATE_FAILED	include/FreeRTOS.h	594;"	d
traceTIMER_EXPIRED	include/FreeRTOS.h	602;"	d
tskBLOCKED_CHAR	tasks.c	99;"	d	file:
tskDEFAULT_INDEX_TO_NOTIFY	include/task.h	74;"	d
tskDELETED_CHAR	tasks.c	101;"	d	file:
tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB	tasks.c	82;"	d	file:
tskIDLE_PRIORITY	include/task.h	180;"	d
tskKERNEL_VERSION_BUILD	include/task.h	59;"	d
tskKERNEL_VERSION_MAJOR	include/task.h	57;"	d
tskKERNEL_VERSION_MINOR	include/task.h	58;"	d
tskKERNEL_VERSION_NUMBER	include/task.h	56;"	d
tskMPU_REGION_DEVICE_MEMORY	include/task.h	67;"	d
tskMPU_REGION_EXECUTE_NEVER	include/task.h	65;"	d
tskMPU_REGION_NORMAL_MEMORY	include/task.h	66;"	d
tskMPU_REGION_READ_ONLY	include/task.h	63;"	d
tskMPU_REGION_READ_WRITE	include/task.h	64;"	d
tskREADY_CHAR	tasks.c	100;"	d	file:
tskRUNNING_CHAR	tasks.c	98;"	d	file:
tskSET_NEW_STACKS_TO_KNOWN_VALUE	tasks.c	90;"	d	file:
tskSET_NEW_STACKS_TO_KNOWN_VALUE	tasks.c	92;"	d	file:
tskSTACK_FILL_BYTE	tasks.c	79;"	d	file:
tskSTATICALLY_ALLOCATED_STACK_AND_TCB	tasks.c	84;"	d	file:
tskSTATICALLY_ALLOCATED_STACK_ONLY	tasks.c	83;"	d	file:
tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	include/FreeRTOS.h	1106;"	d
tskSUSPENDED_CHAR	tasks.c	102;"	d	file:
tskTCB	tasks.c	/^} tskTCB;$/;"	t	typeref:struct:tskTaskControlBlock	file:
tskTaskControlBlock	tasks.c	/^typedef struct tskTaskControlBlock       \/* The old naming convention is used to prevent breaking kernel aware debuggers. *\/$/;"	s	file:
tskTaskControlBlock::iTaskErrno	tasks.c	/^        int iTaskErrno;$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::pcTaskName	tasks.c	/^    char pcTaskName[ configMAX_TASK_NAME_LEN ]; \/*< Descriptive name given to the task when created.  Facilitates debugging only. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::pvThreadLocalStoragePointers	tasks.c	/^        void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::pxEndOfStack	tasks.c	/^        StackType_t * pxEndOfStack; \/*< Points to the highest valid address for the stack. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::pxStack	tasks.c	/^    StackType_t * pxStack;                      \/*< Points to the start of the stack. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::pxTaskTag	tasks.c	/^        TaskHookFunction_t pxTaskTag;$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::pxTopOfStack	tasks.c	/^    volatile StackType_t * pxTopOfStack; \/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::ucDelayAborted	tasks.c	/^        uint8_t ucDelayAborted;$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::ucNotifyState	tasks.c	/^        volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::ucStaticallyAllocated	tasks.c	/^        uint8_t ucStaticallyAllocated;                     \/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::ulNotifiedValue	tasks.c	/^        volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::ulRunTimeCounter	tasks.c	/^        uint32_t ulRunTimeCounter; \/*< Stores the amount of time the task has spent in the Running state. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::uxBasePriority	tasks.c	/^        UBaseType_t uxBasePriority; \/*< The priority last assigned to the task - used by the priority inheritance mechanism. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::uxCriticalNesting	tasks.c	/^        UBaseType_t uxCriticalNesting; \/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::uxMutexesHeld	tasks.c	/^        UBaseType_t uxMutexesHeld;$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::uxPriority	tasks.c	/^    UBaseType_t uxPriority;                     \/*< The priority of the task.  0 is the lowest priority. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::uxTCBNumber	tasks.c	/^        UBaseType_t uxTCBNumber;  \/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::uxTaskNumber	tasks.c	/^        UBaseType_t uxTaskNumber; \/*< Stores a number specifically for use by third party trace code. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::xEventListItem	tasks.c	/^    ListItem_t xEventListItem;                  \/*< Used to reference a task from an event list. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::xMPUSettings	tasks.c	/^        xMPU_SETTINGS xMPUSettings; \/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
tskTaskControlBlock::xNewLib_reent	tasks.c	/^        struct  _reent xNewLib_reent;$/;"	m	struct:tskTaskControlBlock	typeref:struct:tskTaskControlBlock::_reent	file:	access:public
tskTaskControlBlock::xStateListItem	tasks.c	/^    ListItem_t xStateListItem;                  \/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
u	include/FreeRTOS.h	/^    } u;$/;"	m	struct:xSTATIC_QUEUE	typeref:union:xSTATIC_QUEUE::__anon6	access:public
u	queue.c	/^    } u;$/;"	m	struct:QueueDefinition	typeref:union:QueueDefinition::__anon2	file:	access:public
u	timers.c	/^        } u;$/;"	m	struct:tmrTimerQueueMessage	typeref:union:tmrTimerQueueMessage::__anon1	file:	access:public
ucDelayAborted	tasks.c	/^        uint8_t ucDelayAborted;$/;"	m	struct:tskTaskControlBlock	file:	access:public
ucDummy19	include/FreeRTOS.h	/^        uint8_t ucDummy19[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];$/;"	m	struct:xSTATIC_TCB	access:public
ucDummy21	include/FreeRTOS.h	/^        uint8_t ucDummy21;$/;"	m	struct:xSTATIC_TCB	access:public
ucDummy3	include/FreeRTOS.h	/^    uint8_t ucDummy3;$/;"	m	struct:xSTATIC_STREAM_BUFFER	access:public
ucDummy4	include/FreeRTOS.h	/^        uint8_t ucDummy4;$/;"	m	struct:xSTATIC_EVENT_GROUP	access:public
ucDummy5	include/FreeRTOS.h	/^    uint8_t ucDummy5[ 2 ];$/;"	m	struct:xSTATIC_QUEUE	access:public
ucDummy6	include/FreeRTOS.h	/^        uint8_t ucDummy6;$/;"	m	struct:xSTATIC_QUEUE	access:public
ucDummy7	include/FreeRTOS.h	/^    uint8_t ucDummy7[ configMAX_TASK_NAME_LEN ];$/;"	m	struct:xSTATIC_TCB	access:public
ucDummy8	include/FreeRTOS.h	/^    uint8_t ucDummy8;$/;"	m	struct:xSTATIC_TIMER	access:public
ucDummy9	include/FreeRTOS.h	/^        uint8_t ucDummy9;$/;"	m	struct:xSTATIC_QUEUE	access:public
ucFlags	stream_buffer.c	/^    uint8_t ucFlags;$/;"	m	struct:StreamBufferDef_t	file:	access:public
ucHeap	portable/MemMang/heap_1.c	/^    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];$/;"	v	file:
ucHeap	portable/MemMang/heap_2.c	/^    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];$/;"	v	file:
ucHeap	portable/MemMang/heap_4.c	/^    PRIVILEGED_DATA static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];$/;"	v	file:
ucNotifyState	tasks.c	/^        volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];$/;"	m	struct:tskTaskControlBlock	file:	access:public
ucQueueGetQueueType	queue.c	/^    uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )$/;"	f	signature:( QueueHandle_t xQueue )
ucQueueType	queue.c	/^        uint8_t ucQueueType;$/;"	m	struct:QueueDefinition	file:	access:public
ucStaticallyAllocated	event_groups.c	/^        uint8_t ucStaticallyAllocated; \/*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:EventGroupDef_t	file:	access:public
ucStaticallyAllocated	queue.c	/^        uint8_t ucStaticallyAllocated; \/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:QueueDefinition	file:	access:public
ucStaticallyAllocated	tasks.c	/^        uint8_t ucStaticallyAllocated;                     \/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
ucStatus	timers.c	/^        uint8_t ucStatus;                           \/*<< Holds bits to say if the timer was statically allocated or not, and if it is active or not. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
ucStreamBufferGetStreamBufferType	stream_buffer.c	/^    uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
ulDummy16	include/FreeRTOS.h	/^        uint32_t ulDummy16;$/;"	m	struct:xSTATIC_TCB	access:public
ulDummy18	include/FreeRTOS.h	/^        uint32_t ulDummy18[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];$/;"	m	struct:xSTATIC_TCB	access:public
ulLengthInBytes	include/task.h	/^    uint32_t ulLengthInBytes;$/;"	m	struct:xMEMORY_REGION	access:public
ulNotifiedValue	tasks.c	/^        volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];$/;"	m	struct:tskTaskControlBlock	file:	access:public
ulParameter2	timers.c	/^        uint32_t ulParameter2;               \/* << The value that will be used as the callback functions second parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:	access:public
ulParameters	include/task.h	/^    uint32_t ulParameters;$/;"	m	struct:xMEMORY_REGION	access:public
ulPortGetRunTime	portable/ThirdParty/GCC/Posix/port.c	/^unsigned long ulPortGetRunTime( void )$/;"	f	signature:( void )
ulPortGetRunTime	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern unsigned long ulPortGetRunTime( void );$/;"	p	signature:( void )
ulRunTimeCounter	include/task.h	/^    uint32_t ulRunTimeCounter;                       \/* The total run time allocated to the task so far, as defined by the run time stats clock.  See https:\/\/www.FreeRTOS.org\/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS	access:public
ulRunTimeCounter	tasks.c	/^        uint32_t ulRunTimeCounter; \/*< Stores the amount of time the task has spent in the Running state. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
ulTaskGenericNotifyTake	include/mpu_wrappers.h	82;"	d
ulTaskGenericNotifyTake	tasks.c	/^    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,$/;"	f	signature:( UBaseType_t uxIndexToWait, BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
ulTaskGenericNotifyValueClear	include/mpu_wrappers.h	84;"	d
ulTaskGenericNotifyValueClear	tasks.c	/^    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear )
ulTaskGetIdleRunTimeCounter	include/mpu_wrappers.h	79;"	d
ulTaskGetIdleRunTimeCounter	tasks.c	/^    uint32_t ulTaskGetIdleRunTimeCounter( void )$/;"	f	signature:( void )
ulTaskNotifyTake	include/task.h	2584;"	d
ulTaskNotifyTakeIndexed	include/task.h	2586;"	d
ulTaskNotifyValueClear	include/task.h	2714;"	d
ulTaskNotifyValueClearIndexed	include/task.h	2716;"	d
ulTaskSwitchedInTime	tasks.c	/^    PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;    \/*< Holds the value of a timer\/counter the last time a task was switched in. *\/$/;"	v	file:
ulTotalRunTime	tasks.c	/^    PRIVILEGED_DATA static volatile uint32_t ulTotalRunTime = 0UL; \/*< Holds the total amount of execution time as defined by the run time counter clock. *\/$/;"	v	file:
usStackDepth	include/task.h	/^    configSTACK_DEPTH_TYPE usStackDepth;$/;"	m	struct:xTASK_PARAMETERS	access:public
usStackHighWaterMark	include/task.h	/^    configSTACK_DEPTH_TYPE usStackHighWaterMark;     \/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. *\/$/;"	m	struct:xTASK_STATUS	access:public
uxBasePriority	include/task.h	/^    UBaseType_t uxBasePriority;                      \/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS	access:public
uxBasePriority	tasks.c	/^        UBaseType_t uxBasePriority; \/*< The priority last assigned to the task - used by the priority inheritance mechanism. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
uxCriticalNesting	portable/ThirdParty/GCC/Posix/port.c	/^static volatile portBASE_TYPE uxCriticalNesting;$/;"	v	file:
uxCriticalNesting	tasks.c	/^        UBaseType_t uxCriticalNesting; \/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
uxCurrentNumberOfTasks	tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;$/;"	v	file:
uxCurrentPriority	include/task.h	/^    UBaseType_t uxCurrentPriority;                   \/* The priority at which the task was running (may be inherited) when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS	access:public
uxDeletedTasksWaitingCleanUp	tasks.c	/^    PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;$/;"	v	file:
uxDummy1	include/FreeRTOS.h	/^    size_t uxDummy1[ 4 ];$/;"	m	struct:xSTATIC_STREAM_BUFFER	access:public
uxDummy10	include/FreeRTOS.h	/^        UBaseType_t uxDummy10[ 2 ];$/;"	m	struct:xSTATIC_TCB	access:public
uxDummy12	include/FreeRTOS.h	/^        UBaseType_t uxDummy12[ 2 ];$/;"	m	struct:xSTATIC_TCB	access:public
uxDummy2	include/FreeRTOS.h	/^        UBaseType_t uxDummy2;$/;"	m	union:xSTATIC_QUEUE::__anon6	access:public
uxDummy2	include/FreeRTOS.h	/^    UBaseType_t uxDummy2;$/;"	m	struct:xSTATIC_LIST	access:public
uxDummy20	include/FreeRTOS.h	/^        uint8_t uxDummy20;$/;"	m	struct:xSTATIC_TCB	access:public
uxDummy3	include/FreeRTOS.h	/^        UBaseType_t uxDummy3;$/;"	m	struct:xSTATIC_EVENT_GROUP	access:public
uxDummy4	include/FreeRTOS.h	/^        UBaseType_t uxDummy4;$/;"	m	struct:xSTATIC_STREAM_BUFFER	access:public
uxDummy4	include/FreeRTOS.h	/^    UBaseType_t uxDummy4[ 3 ];$/;"	m	struct:xSTATIC_QUEUE	access:public
uxDummy5	include/FreeRTOS.h	/^    UBaseType_t uxDummy5;$/;"	m	struct:xSTATIC_TCB	access:public
uxDummy7	include/FreeRTOS.h	/^        UBaseType_t uxDummy7;$/;"	m	struct:xSTATIC_TIMER	access:public
uxDummy8	include/FreeRTOS.h	/^        UBaseType_t uxDummy8;$/;"	m	struct:xSTATIC_QUEUE	access:public
uxDummy9	include/FreeRTOS.h	/^        UBaseType_t uxDummy9;$/;"	m	struct:xSTATIC_TCB	access:public
uxEventBits	event_groups.c	/^    EventBits_t uxEventBits;$/;"	m	struct:EventGroupDef_t	file:	access:public
uxEventGroupGetNumber	event_groups.c	/^    UBaseType_t uxEventGroupGetNumber( void * xEventGroup )$/;"	f	signature:( void * xEventGroup )
uxEventGroupNumber	event_groups.c	/^        UBaseType_t uxEventGroupNumber;$/;"	m	struct:EventGroupDef_t	file:	access:public
uxIndex	include/croutine.h	/^    UBaseType_t uxIndex;         \/*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
uxItemSize	queue.c	/^    UBaseType_t uxItemSize;                 \/*< The size of each items that the queue will hold. *\/$/;"	m	struct:QueueDefinition	file:	access:public
uxLength	queue.c	/^    UBaseType_t uxLength;                   \/*< The length of the queue defined as the number of items it will hold, not the number of bytes. *\/$/;"	m	struct:QueueDefinition	file:	access:public
uxListRemove	list.c	/^UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )$/;"	f	signature:( ListItem_t * const pxItemToRemove )
uxMessagesWaiting	queue.c	/^    volatile UBaseType_t uxMessagesWaiting; \/*< The number of items currently in the queue. *\/$/;"	m	struct:QueueDefinition	file:	access:public
uxMutexesHeld	tasks.c	/^        UBaseType_t uxMutexesHeld;$/;"	m	struct:tskTaskControlBlock	file:	access:public
uxNumberOfItems	include/list.h	/^    volatile UBaseType_t uxNumberOfItems;$/;"	m	struct:xLIST	access:public
uxPriority	include/croutine.h	/^    UBaseType_t uxPriority;      \/*< The priority of the co-routine in relation to other co-routines. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
uxPriority	include/task.h	/^    UBaseType_t uxPriority;$/;"	m	struct:xTASK_PARAMETERS	access:public
uxPriority	tasks.c	/^    UBaseType_t uxPriority;                     \/*< The priority of the task.  0 is the lowest priority. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
uxQueueGetQueueNumber	queue.c	/^    UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )$/;"	f	signature:( QueueHandle_t xQueue )
uxQueueMessagesWaiting	include/mpu_wrappers.h	97;"	d
uxQueueMessagesWaiting	queue.c	/^UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )$/;"	f	signature:( const QueueHandle_t xQueue )
uxQueueMessagesWaitingFromISR	queue.c	/^UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )$/;"	f	signature:( const QueueHandle_t xQueue )
uxQueueNumber	queue.c	/^        UBaseType_t uxQueueNumber;$/;"	m	struct:QueueDefinition	file:	access:public
uxQueueSpacesAvailable	include/mpu_wrappers.h	98;"	d
uxQueueSpacesAvailable	queue.c	/^UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )$/;"	f	signature:( const QueueHandle_t xQueue )
uxQueueType	queue.c	66;"	d	file:
uxRecursiveCallCount	queue.c	/^    UBaseType_t uxRecursiveCallCount; \/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. *\/$/;"	m	struct:SemaphoreData	file:	access:public
uxSchedulerSuspended	tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;$/;"	v	file:
uxSemaphoreGetCount	include/semphr.h	1173;"	d
uxState	include/croutine.h	/^    uint16_t uxState;            \/*< Used internally by the co-routine implementation. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
uxStreamBufferGetStreamBufferNumber	stream_buffer.c	/^    UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
uxStreamBufferNumber	stream_buffer.c	/^        UBaseType_t uxStreamBufferNumber; \/* Used for tracing purposes. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
uxTCBNumber	tasks.c	/^        UBaseType_t uxTCBNumber;  \/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
uxTaskGetNumberOfTasks	include/mpu_wrappers.h	65;"	d
uxTaskGetNumberOfTasks	tasks.c	/^UBaseType_t uxTaskGetNumberOfTasks( void )$/;"	f	signature:( void )
uxTaskGetStackHighWaterMark	include/mpu_wrappers.h	68;"	d
uxTaskGetStackHighWaterMark	tasks.c	/^    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )$/;"	f	signature:( TaskHandle_t xTask )
uxTaskGetStackHighWaterMark2	include/mpu_wrappers.h	69;"	d
uxTaskGetStackHighWaterMark2	tasks.c	/^    configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )$/;"	f	signature:( TaskHandle_t xTask )
uxTaskGetSystemState	include/mpu_wrappers.h	76;"	d
uxTaskGetSystemState	tasks.c	/^    UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,$/;"	f	signature:( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
uxTaskGetTaskNumber	tasks.c	/^    UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )$/;"	f	signature:( TaskHandle_t xTask )
uxTaskNumber	tasks.c	/^        UBaseType_t uxTaskNumber; \/*< Stores a number specifically for use by third party trace code. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
uxTaskNumber	tasks.c	/^PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;$/;"	v	file:
uxTaskPriorityGet	include/mpu_wrappers.h	56;"	d
uxTaskPriorityGet	tasks.c	/^    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )$/;"	f	signature:( const TaskHandle_t xTask )
uxTaskPriorityGetFromISR	tasks.c	/^    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )$/;"	f	signature:( const TaskHandle_t xTask )
uxTaskResetEventItemValue	tasks.c	/^TickType_t uxTaskResetEventItemValue( void )$/;"	f	signature:( void )
uxTimerGetReloadMode	include/mpu_wrappers.h	131;"	d
uxTimerGetReloadMode	timers.c	/^    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )$/;"	f	signature:( TimerHandle_t xTimer )
uxTimerGetTimerNumber	timers.c	/^        UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )$/;"	f	signature:( TimerHandle_t xTimer )
uxTimerNumber	timers.c	/^            UBaseType_t uxTimerNumber;              \/*<< An ID assigned by trace tools such as FreeRTOS+Trace *\/$/;"	m	struct:tmrTimerControl	file:	access:public
uxTopCoRoutineReadyPriority	croutine.c	/^    static UBaseType_t uxTopCoRoutineReadyPriority = 0;$/;"	v	file:
uxTopReadyPriority	tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;$/;"	v	file:
uxTopUsedPriority	tasks.c	/^const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;$/;"	v
vApplicationGetIdleTaskMemory	include/task.h	/^    void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer,$/;"	p	signature:( StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t * pulIdleTaskStackSize )
vApplicationGetTimerTaskMemory	include/timers.h	/^    void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer,$/;"	p	signature:( StaticTask_t ** ppxTimerTaskTCBBuffer, StackType_t ** ppxTimerTaskStackBuffer, uint32_t * pulTimerTaskStackSize )
vApplicationStackOverflowHook	include/task.h	/^     void vApplicationStackOverflowHook( TaskHandle_t xTask,$/;"	p	signature:( TaskHandle_t xTask, char * pcTaskName )
vApplicationTickHook	include/task.h	/^    void vApplicationTickHook( void ); \/*lint !e526 Symbol not defined as it is an application callback. *\/$/;"	p	signature:( void )
vCoRoutineAddToDelayedList	croutine.c	/^    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,$/;"	f	signature:( TickType_t xTicksToDelay, List_t * pxEventList )
vCoRoutineAddToDelayedList	include/croutine.h	/^void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,$/;"	p	signature:( TickType_t xTicksToDelay, List_t * pxEventList )
vCoRoutineSchedule	croutine.c	/^    void vCoRoutineSchedule( void )$/;"	f	signature:( void )
vCoRoutineSchedule	include/croutine.h	/^void vCoRoutineSchedule( void );$/;"	p	signature:( void )
vEventGroupClearBitsCallback	event_groups.c	/^void vEventGroupClearBitsCallback( void * pvEventGroup,$/;"	f	signature:( void * pvEventGroup, const uint32_t ulBitsToClear )
vEventGroupDelete	event_groups.c	/^void vEventGroupDelete( EventGroupHandle_t xEventGroup )$/;"	f	signature:( EventGroupHandle_t xEventGroup )
vEventGroupDelete	include/mpu_wrappers.h	143;"	d
vEventGroupSetBitsCallback	event_groups.c	/^void vEventGroupSetBitsCallback( void * pvEventGroup,$/;"	f	signature:( void * pvEventGroup, const uint32_t ulBitsToSet )
vEventGroupSetNumber	event_groups.c	/^    void vEventGroupSetNumber( void * xEventGroup,$/;"	f	signature:( void * xEventGroup, UBaseType_t uxEventGroupNumber )
vListInitialise	list.c	/^void vListInitialise( List_t * const pxList )$/;"	f	signature:( List_t * const pxList )
vListInitialiseItem	list.c	/^void vListInitialiseItem( ListItem_t * const pxItem )$/;"	f	signature:( ListItem_t * const pxItem )
vListInsert	list.c	/^void vListInsert( List_t * const pxList,$/;"	f	signature:( List_t * const pxList, ListItem_t * const pxNewListItem )
vListInsertEnd	list.c	/^void vListInsertEnd( List_t * const pxList,$/;"	f	signature:( List_t * const pxList, ListItem_t * const pxNewListItem )
vMessageBufferDelete	include/message_buffer.h	629;"	d
vPortCancelThread	portable/ThirdParty/GCC/Posix/port.c	/^void vPortCancelThread( void *pxTaskToDelete )$/;"	f	signature:( void *pxTaskToDelete )
vPortCancelThread	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern void vPortCancelThread( void *pxTaskToDelete );$/;"	p	signature:( void *pxTaskToDelete )
vPortClearInterruptMask	portable/ThirdParty/GCC/Posix/port.c	/^void vPortClearInterruptMask( portBASE_TYPE xMask )$/;"	f	signature:( portBASE_TYPE xMask )
vPortClearInterruptMask	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern void vPortClearInterruptMask( portBASE_TYPE xMask );$/;"	p	signature:( portBASE_TYPE xMask )
vPortDefineHeapRegions	portable/MemMang/heap_5.c	/^void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )$/;"	f	signature:( const HeapRegion_t * const pxHeapRegions )
vPortDisableInterrupts	portable/ThirdParty/GCC/Posix/port.c	/^void vPortDisableInterrupts( void )$/;"	f	signature:( void )
vPortDisableInterrupts	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern void vPortDisableInterrupts( void );$/;"	p	signature:( void )
vPortEnableInterrupts	portable/ThirdParty/GCC/Posix/port.c	/^void vPortEnableInterrupts( void )$/;"	f	signature:( void )
vPortEnableInterrupts	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern void vPortEnableInterrupts( void );$/;"	p	signature:( void )
vPortEndScheduler	portable/ThirdParty/GCC/Posix/port.c	/^void vPortEndScheduler( void )$/;"	f	signature:( void )
vPortEnterCritical	portable/ThirdParty/GCC/Posix/port.c	/^void vPortEnterCritical( void )$/;"	f	signature:( void )
vPortEnterCritical	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern void vPortEnterCritical( void );$/;"	p	signature:( void )
vPortExitCritical	portable/ThirdParty/GCC/Posix/port.c	/^void vPortExitCritical( void )$/;"	f	signature:( void )
vPortExitCritical	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern void vPortExitCritical( void );$/;"	p	signature:( void )
vPortFree	portable/MemMang/heap_1.c	/^void vPortFree( void * pv )$/;"	f	signature:( void * pv )
vPortFree	portable/MemMang/heap_2.c	/^void vPortFree( void * pv )$/;"	f	signature:( void * pv )
vPortFree	portable/MemMang/heap_3.c	/^void vPortFree( void * pv )$/;"	f	signature:( void * pv )
vPortFree	portable/MemMang/heap_4.c	/^void vPortFree( void * pv )$/;"	f	signature:( void * pv )
vPortFree	portable/MemMang/heap_5.c	/^void vPortFree( void * pv )$/;"	f	signature:( void * pv )
vPortFreeStack	include/portable.h	186;"	d
vPortGetHeapStats	include/portable.h	/^void vPortGetHeapStats( HeapStats_t * pxHeapStats );$/;"	p	signature:( HeapStats_t * pxHeapStats )
vPortGetHeapStats	portable/MemMang/heap_4.c	/^void vPortGetHeapStats( HeapStats_t * pxHeapStats )$/;"	f	signature:( HeapStats_t * pxHeapStats )
vPortGetHeapStats	portable/MemMang/heap_5.c	/^void vPortGetHeapStats( HeapStats_t * pxHeapStats )$/;"	f	signature:( HeapStats_t * pxHeapStats )
vPortInitialiseBlocks	portable/MemMang/heap_1.c	/^void vPortInitialiseBlocks( void )$/;"	f	signature:( void )
vPortInitialiseBlocks	portable/MemMang/heap_2.c	/^void vPortInitialiseBlocks( void )$/;"	f	signature:( void )
vPortInitialiseBlocks	portable/MemMang/heap_4.c	/^void vPortInitialiseBlocks( void )$/;"	f	signature:( void )
vPortResetPrivilege	portable/Common/mpu_wrappers.c	/^void vPortResetPrivilege( BaseType_t xRunningPrivileged )$/;"	f	signature:( BaseType_t xRunningPrivileged )
vPortResetPrivilege	portable/Common/mpu_wrappers.c	/^void vPortResetPrivilege( BaseType_t xRunningPrivileged );$/;"	p	file:	signature:( BaseType_t xRunningPrivileged )
vPortStartFirstTask	portable/ThirdParty/GCC/Posix/port.c	/^static void vPortStartFirstTask( void );$/;"	p	file:	signature:( void )
vPortStartFirstTask	portable/ThirdParty/GCC/Posix/port.c	/^void vPortStartFirstTask( void )$/;"	f	signature:( void )
vPortSystemTickHandler	portable/ThirdParty/GCC/Posix/port.c	/^static void vPortSystemTickHandler( int sig )$/;"	f	file:	signature:( int sig )
vPortSystemTickHandler	portable/ThirdParty/GCC/Posix/port.c	/^static void vPortSystemTickHandler( int sig );$/;"	p	file:	signature:( int sig )
vPortThreadDying	portable/ThirdParty/GCC/Posix/port.c	/^void vPortThreadDying( void *pxTaskToDelete, volatile BaseType_t *pxPendYield )$/;"	f	signature:( void *pxTaskToDelete, volatile BaseType_t *pxPendYield )
vPortThreadDying	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern void vPortThreadDying( void *pxTaskToDelete, volatile BaseType_t *pxPendYield );$/;"	p	signature:( void *pxTaskToDelete, volatile BaseType_t *pxPendYield )
vPortYield	portable/ThirdParty/GCC/Posix/port.c	/^void vPortYield( void )$/;"	f	signature:( void )
vPortYield	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern void vPortYield( void );$/;"	p	signature:( void )
vPortYieldFromISR	portable/ThirdParty/GCC/Posix/port.c	/^void vPortYieldFromISR( void )$/;"	f	signature:( void )
vQueueAddToRegistry	include/FreeRTOS.h	330;"	d
vQueueAddToRegistry	include/mpu_wrappers.h	116;"	d
vQueueAddToRegistry	queue.c	/^    void vQueueAddToRegistry( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, const char * pcQueueName )
vQueueDelete	include/mpu_wrappers.h	99;"	d
vQueueDelete	queue.c	/^void vQueueDelete( QueueHandle_t xQueue )$/;"	f	signature:( QueueHandle_t xQueue )
vQueueSetQueueNumber	queue.c	/^    void vQueueSetQueueNumber( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
vQueueUnregisterQueue	include/FreeRTOS.h	331;"	d
vQueueUnregisterQueue	include/mpu_wrappers.h	117;"	d
vQueueUnregisterQueue	queue.c	/^    void vQueueUnregisterQueue( QueueHandle_t xQueue )$/;"	f	signature:( QueueHandle_t xQueue )
vQueueWaitForMessageRestricted	queue.c	/^    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
vSemaphoreCreateBinary	include/semphr.h	97;"	d
vSemaphoreDelete	include/semphr.h	1129;"	d
vStreamBufferDelete	include/mpu_wrappers.h	150;"	d
vStreamBufferDelete	stream_buffer.c	/^void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
vStreamBufferSetStreamBufferNumber	stream_buffer.c	/^    void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
vTaskAllocateMPURegions	tasks.c	/^    void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,$/;"	f	signature:( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
vTaskDelay	include/mpu_wrappers.h	53;"	d
vTaskDelay	tasks.c	/^    void vTaskDelay( const TickType_t xTicksToDelay )$/;"	f	signature:( const TickType_t xTicksToDelay )
vTaskDelayUntil	include/task.h	862;"	d
vTaskDelete	include/mpu_wrappers.h	52;"	d
vTaskDelete	tasks.c	/^    void vTaskDelete( TaskHandle_t xTaskToDelete )$/;"	f	signature:( TaskHandle_t xTaskToDelete )
vTaskEndScheduler	tasks.c	/^void vTaskEndScheduler( void )$/;"	f	signature:( void )
vTaskEnterCritical	tasks.c	/^    void vTaskEnterCritical( void )$/;"	f	signature:( void )
vTaskExitCritical	tasks.c	/^    void vTaskExitCritical( void )$/;"	f	signature:( void )
vTaskGenericNotifyGiveFromISR	tasks.c	/^    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,$/;"	f	signature:( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, BaseType_t * pxHigherPriorityTaskWoken )
vTaskGetInfo	include/mpu_wrappers.h	58;"	d
vTaskGetInfo	tasks.c	/^    void vTaskGetInfo( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, TaskStatus_t * pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
vTaskGetRunTimeStats	include/mpu_wrappers.h	78;"	d
vTaskGetRunTimeStats	tasks.c	/^    void vTaskGetRunTimeStats( char * pcWriteBuffer )$/;"	f	signature:( char * pcWriteBuffer )
vTaskGetTaskInfo	include/FreeRTOS.h	1008;"	d
vTaskInternalSetTimeOutState	tasks.c	/^void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )$/;"	f	signature:( TimeOut_t * const pxTimeOut )
vTaskList	include/mpu_wrappers.h	77;"	d
vTaskList	tasks.c	/^    void vTaskList( char * pcWriteBuffer )$/;"	f	signature:( char * pcWriteBuffer )
vTaskMissedYield	tasks.c	/^void vTaskMissedYield( void )$/;"	f	signature:( void )
vTaskNotifyGiveFromISR	include/task.h	2478;"	d
vTaskNotifyGiveIndexedFromISR	include/task.h	2480;"	d
vTaskPlaceOnEventList	tasks.c	/^void vTaskPlaceOnEventList( List_t * const pxEventList,$/;"	f	signature:( List_t * const pxEventList, const TickType_t xTicksToWait )
vTaskPlaceOnEventListRestricted	tasks.c	/^    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,$/;"	f	signature:( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
vTaskPlaceOnUnorderedEventList	tasks.c	/^void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,$/;"	f	signature:( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
vTaskPriorityDisinheritAfterTimeout	tasks.c	/^    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,$/;"	f	signature:( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
vTaskPrioritySet	include/mpu_wrappers.h	59;"	d
vTaskPrioritySet	tasks.c	/^    void vTaskPrioritySet( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, UBaseType_t uxNewPriority )
vTaskRemoveFromUnorderedEventList	tasks.c	/^void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,$/;"	f	signature:( ListItem_t * pxEventListItem, const TickType_t xItemValue )
vTaskResume	include/mpu_wrappers.h	61;"	d
vTaskResume	tasks.c	/^    void vTaskResume( TaskHandle_t xTaskToResume )$/;"	f	signature:( TaskHandle_t xTaskToResume )
vTaskSetApplicationTaskTag	include/mpu_wrappers.h	70;"	d
vTaskSetApplicationTaskTag	tasks.c	/^    void vTaskSetApplicationTaskTag( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
vTaskSetTaskNumber	tasks.c	/^    void vTaskSetTaskNumber( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, const UBaseType_t uxHandle )
vTaskSetThreadLocalStoragePointer	include/mpu_wrappers.h	72;"	d
vTaskSetThreadLocalStoragePointer	tasks.c	/^    void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,$/;"	f	signature:( TaskHandle_t xTaskToSet, BaseType_t xIndex, void * pvValue )
vTaskSetTimeOutState	include/mpu_wrappers.h	88;"	d
vTaskSetTimeOutState	tasks.c	/^void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )$/;"	f	signature:( TimeOut_t * const pxTimeOut )
vTaskStartScheduler	tasks.c	/^void vTaskStartScheduler( void )$/;"	f	signature:( void )
vTaskStepTick	tasks.c	/^    void vTaskStepTick( const TickType_t xTicksToJump )$/;"	f	signature:( const TickType_t xTicksToJump )
vTaskSuspend	include/mpu_wrappers.h	60;"	d
vTaskSuspend	tasks.c	/^    void vTaskSuspend( TaskHandle_t xTaskToSuspend )$/;"	f	signature:( TaskHandle_t xTaskToSuspend )
vTaskSuspendAll	include/mpu_wrappers.h	62;"	d
vTaskSuspendAll	tasks.c	/^void vTaskSuspendAll( void )$/;"	f	signature:( void )
vTaskSwitchContext	tasks.c	/^void vTaskSwitchContext( void )$/;"	f	signature:( void )
vTimerSetReloadMode	include/mpu_wrappers.h	130;"	d
vTimerSetReloadMode	timers.c	/^    void vTimerSetReloadMode( TimerHandle_t xTimer,$/;"	f	signature:( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
vTimerSetTimerID	include/mpu_wrappers.h	125;"	d
vTimerSetTimerID	timers.c	/^    void vTimerSetTimerID( TimerHandle_t xTimer,$/;"	f	signature:( TimerHandle_t xTimer, void * pvNewID )
vTimerSetTimerNumber	timers.c	/^        void vTimerSetTimerNumber( TimerHandle_t xTimer,$/;"	f	signature:( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
xActiveTimerList1	timers.c	/^    PRIVILEGED_DATA static List_t xActiveTimerList1;$/;"	v	file:
xActiveTimerList2	timers.c	/^    PRIVILEGED_DATA static List_t xActiveTimerList2;$/;"	v	file:
xAllSignals	portable/ThirdParty/GCC/Posix/port.c	/^static sigset_t xAllSignals;$/;"	v	file:
xAvailableHeapSpaceInBytes	include/portable.h	/^    size_t xAvailableHeapSpaceInBytes;          \/* The total heap size currently available - this is the sum of all the free blocks, not the largest block that can be allocated. *\/$/;"	m	struct:xHeapStats	access:public
xBlockAllocatedBit	portable/MemMang/heap_4.c	/^PRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;$/;"	v	file:
xBlockAllocatedBit	portable/MemMang/heap_5.c	/^static size_t xBlockAllocatedBit = 0;$/;"	v	file:
xBlockSize	portable/MemMang/heap_2.c	/^    size_t xBlockSize;                     \/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:	access:public
xBlockSize	portable/MemMang/heap_4.c	/^    size_t xBlockSize;                     \/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:	access:public
xBlockSize	portable/MemMang/heap_5.c	/^    size_t xBlockSize;                     \/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:	access:public
xCallbackParameters	timers.c	/^                CallbackParameters_t xCallbackParameters;$/;"	m	union:tmrTimerQueueMessage::__anon1	file:	access:public
xCoRoutineCreate	croutine.c	/^    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,$/;"	f	signature:( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
xCoRoutineCreate	include/croutine.h	/^BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,$/;"	p	signature:( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
xCoRoutineHandle	include/FreeRTOS.h	1002;"	d
xCoRoutineRemoveFromEventList	croutine.c	/^    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )$/;"	f	signature:( const List_t * pxEventList )
xCoRoutineRemoveFromEventList	include/croutine.h	/^BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList );$/;"	p	signature:( const List_t * pxEventList )
xCoRoutineTickCount	croutine.c	/^    static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xDelayedCoRoutineList1	croutine.c	/^    static List_t xDelayedCoRoutineList1;                                   \/*< Delayed co-routines. *\/$/;"	v	file:
xDelayedCoRoutineList2	croutine.c	/^    static List_t xDelayedCoRoutineList2;                                   \/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. *\/$/;"	v	file:
xDelayedTaskList1	tasks.c	/^PRIVILEGED_DATA static List_t xDelayedTaskList1;                         \/*< Delayed tasks. *\/$/;"	v	file:
xDelayedTaskList2	tasks.c	/^PRIVILEGED_DATA static List_t xDelayedTaskList2;                         \/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. *\/$/;"	v	file:
xDummy1	include/FreeRTOS.h	/^        TickType_t xDummy1;$/;"	m	struct:xSTATIC_LIST	access:public
xDummy1	include/FreeRTOS.h	/^        TickType_t xDummy1;$/;"	m	struct:xSTATIC_LIST_ITEM	access:public
xDummy1	include/FreeRTOS.h	/^        TickType_t xDummy1;$/;"	m	struct:xSTATIC_MINI_LIST_ITEM	access:public
xDummy1	include/FreeRTOS.h	/^    TickType_t xDummy1;$/;"	m	struct:xSTATIC_EVENT_GROUP	access:public
xDummy17	include/FreeRTOS.h	/^        struct  _reent xDummy17;$/;"	m	struct:xSTATIC_TCB	typeref:struct:xSTATIC_TCB::_reent	access:public
xDummy2	include/FreeRTOS.h	/^        xMPU_SETTINGS xDummy2;$/;"	m	struct:xSTATIC_TCB	access:public
xDummy2	include/FreeRTOS.h	/^    StaticListItem_t xDummy2;$/;"	m	struct:xSTATIC_TIMER	access:public
xDummy2	include/FreeRTOS.h	/^    StaticList_t xDummy2;$/;"	m	struct:xSTATIC_EVENT_GROUP	access:public
xDummy2	include/FreeRTOS.h	/^    TickType_t xDummy2;$/;"	m	struct:xSTATIC_LIST_ITEM	access:public
xDummy2	include/FreeRTOS.h	/^    TickType_t xDummy2;$/;"	m	struct:xSTATIC_MINI_LIST_ITEM	access:public
xDummy3	include/FreeRTOS.h	/^    StaticListItem_t xDummy3[ 2 ];$/;"	m	struct:xSTATIC_TCB	access:public
xDummy3	include/FreeRTOS.h	/^    StaticList_t xDummy3[ 2 ];$/;"	m	struct:xSTATIC_QUEUE	access:public
xDummy3	include/FreeRTOS.h	/^    TickType_t xDummy3;$/;"	m	struct:xSTATIC_TIMER	access:public
xDummy4	include/FreeRTOS.h	/^        TickType_t xDummy4;$/;"	m	struct:xSTATIC_LIST_ITEM	access:public
xDummy4	include/FreeRTOS.h	/^    StaticMiniListItem_t xDummy4;$/;"	m	struct:xSTATIC_LIST	access:public
xDummy5	include/FreeRTOS.h	/^        TickType_t xDummy5;$/;"	m	struct:xSTATIC_LIST	access:public
xDying	portable/ThirdParty/GCC/Posix/port.c	/^    BaseType_t xDying;$/;"	m	struct:THREAD	file:	access:public
xEnd	portable/MemMang/heap_2.c	/^static BlockLink_t xStart, xEnd;$/;"	v	file:
xEventGroupClearBits	event_groups.c	/^EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
xEventGroupClearBits	include/mpu_wrappers.h	140;"	d
xEventGroupClearBitsFromISR	event_groups.c	/^    BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
xEventGroupClearBitsFromISR	include/event_groups.h	419;"	d
xEventGroupCreate	event_groups.c	/^    EventGroupHandle_t xEventGroupCreate( void )$/;"	f	signature:( void )
xEventGroupCreate	include/mpu_wrappers.h	137;"	d
xEventGroupCreateStatic	event_groups.c	/^    EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer )$/;"	f	signature:( StaticEventGroup_t * pxEventGroupBuffer )
xEventGroupCreateStatic	include/mpu_wrappers.h	138;"	d
xEventGroupGetBits	include/event_groups.h	725;"	d
xEventGroupGetBitsFromISR	event_groups.c	/^EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )$/;"	f	signature:( EventGroupHandle_t xEventGroup )
xEventGroupSetBits	event_groups.c	/^EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
xEventGroupSetBits	include/mpu_wrappers.h	141;"	d
xEventGroupSetBitsFromISR	event_groups.c	/^    BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t * pxHigherPriorityTaskWoken )
xEventGroupSetBitsFromISR	include/event_groups.h	575;"	d
xEventGroupSync	event_groups.c	/^EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
xEventGroupSync	include/mpu_wrappers.h	142;"	d
xEventGroupWaitBits	event_groups.c	/^EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,$/;"	f	signature:( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
xEventGroupWaitBits	include/mpu_wrappers.h	139;"	d
xEventListItem	include/croutine.h	/^    ListItem_t xEventListItem;   \/*< List item used to place the CRCB in event lists. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
xEventListItem	tasks.c	/^    ListItem_t xEventListItem;                  \/*< Used to reference a task from an event list. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
xFreeBytesRemaining	portable/MemMang/heap_2.c	/^static size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;$/;"	v	file:
xFreeBytesRemaining	portable/MemMang/heap_4.c	/^PRIVILEGED_DATA static size_t xFreeBytesRemaining = 0U;$/;"	v	file:
xFreeBytesRemaining	portable/MemMang/heap_5.c	/^static size_t xFreeBytesRemaining = 0U;$/;"	v	file:
xGenericListItem	include/croutine.h	/^    ListItem_t xGenericListItem; \/*< List item used to place the CRCB in ready and blocked queues. *\/$/;"	m	struct:corCoRoutineControlBlock	access:public
xHandle	include/task.h	/^    TaskHandle_t xHandle;                            \/* The handle of the task to which the rest of the information in the structure relates. *\/$/;"	m	struct:xTASK_STATUS	access:public
xHandle	queue.c	/^        QueueHandle_t xHandle;$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:	access:public
xHead	stream_buffer.c	/^    volatile size_t xHead;                       \/* Index to the next item to write within the buffer. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
xHeapStats	include/portable.h	/^typedef struct xHeapStats$/;"	s
xHeapStats::xAvailableHeapSpaceInBytes	include/portable.h	/^    size_t xAvailableHeapSpaceInBytes;          \/* The total heap size currently available - this is the sum of all the free blocks, not the largest block that can be allocated. *\/$/;"	m	struct:xHeapStats	access:public
xHeapStats::xMinimumEverFreeBytesRemaining	include/portable.h	/^    size_t xMinimumEverFreeBytesRemaining;      \/* The minimum amount of total free memory (sum of all free blocks) there has been in the heap since the system booted. *\/$/;"	m	struct:xHeapStats	access:public
xHeapStats::xNumberOfFreeBlocks	include/portable.h	/^    size_t xNumberOfFreeBlocks;                 \/* The number of free memory blocks within the heap at the time vPortGetHeapStats() is called. *\/$/;"	m	struct:xHeapStats	access:public
xHeapStats::xNumberOfSuccessfulAllocations	include/portable.h	/^    size_t xNumberOfSuccessfulAllocations;      \/* The number of calls to pvPortMalloc() that have returned a valid memory block. *\/$/;"	m	struct:xHeapStats	access:public
xHeapStats::xNumberOfSuccessfulFrees	include/portable.h	/^    size_t xNumberOfSuccessfulFrees;            \/* The number of calls to vPortFree() that has successfully freed a block of memory. *\/$/;"	m	struct:xHeapStats	access:public
xHeapStats::xSizeOfLargestFreeBlockInBytes	include/portable.h	/^    size_t xSizeOfLargestFreeBlockInBytes;      \/* The maximum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. *\/$/;"	m	struct:xHeapStats	access:public
xHeapStats::xSizeOfSmallestFreeBlockInBytes	include/portable.h	/^    size_t xSizeOfSmallestFreeBlockInBytes;     \/* The minimum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. *\/$/;"	m	struct:xHeapStats	access:public
xHeapStructSize	portable/MemMang/heap_4.c	/^static const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );$/;"	v	file:
xHeapStructSize	portable/MemMang/heap_5.c	/^static const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );$/;"	v	file:
xIdleTaskHandle	tasks.c	/^PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                          \/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. *\/$/;"	v	file:
xItemValue	include/list.h	/^    configLIST_VOLATILE TickType_t xItemValue;          \/*< The value being listed.  In most cases this is used to sort the list in ascending order. *\/$/;"	m	struct:xLIST_ITEM	access:public
xItemValue	include/list.h	/^    configLIST_VOLATILE TickType_t xItemValue;$/;"	m	struct:xMINI_LIST_ITEM	access:public
xLIST	include/list.h	/^typedef struct xLIST$/;"	s
xLIST::pxIndex	include/list.h	/^    ListItem_t * configLIST_VOLATILE pxIndex; \/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). *\/$/;"	m	struct:xLIST	access:public
xLIST::uxNumberOfItems	include/list.h	/^    volatile UBaseType_t uxNumberOfItems;$/;"	m	struct:xLIST	access:public
xLIST::xListEnd	include/list.h	/^    MiniListItem_t xListEnd;                  \/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. *\/$/;"	m	struct:xLIST	access:public
xLIST_ITEM	include/list.h	/^struct xLIST_ITEM$/;"	s
xLIST_ITEM::pvOwner	include/list.h	/^    void * pvOwner;                                     \/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. *\/$/;"	m	struct:xLIST_ITEM	access:public
xLIST_ITEM::pxContainer	include/list.h	/^    struct xLIST * configLIST_VOLATILE pxContainer;     \/*< Pointer to the list in which this list item is placed (if any). *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE	access:public
xLIST_ITEM::pxNext	include/list.h	/^    struct xLIST_ITEM * configLIST_VOLATILE pxNext;     \/*< Pointer to the next ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE	access:public
xLIST_ITEM::pxPrevious	include/list.h	/^    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; \/*< Pointer to the previous ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE	access:public
xLIST_ITEM::xItemValue	include/list.h	/^    configLIST_VOLATILE TickType_t xItemValue;          \/*< The value being listed.  In most cases this is used to sort the list in ascending order. *\/$/;"	m	struct:xLIST_ITEM	access:public
xLastTickCount	croutine.c	/^    static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xLength	stream_buffer.c	/^    size_t xLength;                              \/* The length of the buffer pointed to by pucBuffer. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
xList	include/FreeRTOS.h	1016;"	d
xListEnd	include/list.h	/^    MiniListItem_t xListEnd;                  \/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. *\/$/;"	m	struct:xLIST	access:public
xListItem	include/FreeRTOS.h	1015;"	d
xMEMORY_REGION	include/task.h	/^typedef struct xMEMORY_REGION$/;"	s
xMEMORY_REGION::pvBaseAddress	include/task.h	/^    void * pvBaseAddress;$/;"	m	struct:xMEMORY_REGION	access:public
xMEMORY_REGION::ulLengthInBytes	include/task.h	/^    uint32_t ulLengthInBytes;$/;"	m	struct:xMEMORY_REGION	access:public
xMEMORY_REGION::ulParameters	include/task.h	/^    uint32_t ulParameters;$/;"	m	struct:xMEMORY_REGION	access:public
xMINI_LIST_ITEM	include/list.h	/^struct xMINI_LIST_ITEM$/;"	s
xMINI_LIST_ITEM::pxNext	include/list.h	/^    struct xLIST_ITEM * configLIST_VOLATILE pxNext;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE	access:public
xMINI_LIST_ITEM::pxPrevious	include/list.h	/^    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE	access:public
xMINI_LIST_ITEM::xItemValue	include/list.h	/^    configLIST_VOLATILE TickType_t xItemValue;$/;"	m	struct:xMINI_LIST_ITEM	access:public
xMPUSettings	tasks.c	/^        xMPU_SETTINGS xMPUSettings; \/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
xMemoryRegion	include/FreeRTOS.h	998;"	d
xMessageBufferCreate	include/message_buffer.h	145;"	d
xMessageBufferCreateStatic	include/message_buffer.h	212;"	d
xMessageBufferIsEmpty	include/message_buffer.h	664;"	d
xMessageBufferIsFull	include/message_buffer.h	647;"	d
xMessageBufferNextLengthBytes	include/message_buffer.h	733;"	d
xMessageBufferReceive	include/message_buffer.h	506;"	d
xMessageBufferReceiveCompletedFromISR	include/message_buffer.h	814;"	d
xMessageBufferReceiveFromISR	include/message_buffer.h	608;"	d
xMessageBufferReset	include/message_buffer.h	688;"	d
xMessageBufferSend	include/message_buffer.h	312;"	d
xMessageBufferSendCompletedFromISR	include/message_buffer.h	773;"	d
xMessageBufferSendFromISR	include/message_buffer.h	417;"	d
xMessageBufferSpaceAvailable	include/message_buffer.h	711;"	d
xMessageBufferSpacesAvailable	include/message_buffer.h	713;"	d
xMessageID	timers.c	/^        BaseType_t xMessageID; \/*<< The command being sent to the timer service task. *\/$/;"	m	struct:tmrTimerQueueMessage	file:	access:public
xMessageValue	timers.c	/^        TickType_t xMessageValue; \/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. *\/$/;"	m	struct:tmrTimerParameters	file:	access:public
xMinimumEverFreeBytesRemaining	include/portable.h	/^    size_t xMinimumEverFreeBytesRemaining;      \/* The minimum amount of total free memory (sum of all free blocks) there has been in the heap since the system booted. *\/$/;"	m	struct:xHeapStats	access:public
xMinimumEverFreeBytesRemaining	portable/MemMang/heap_4.c	/^PRIVILEGED_DATA static size_t xMinimumEverFreeBytesRemaining = 0U;$/;"	v	file:
xMinimumEverFreeBytesRemaining	portable/MemMang/heap_5.c	/^static size_t xMinimumEverFreeBytesRemaining = 0U;$/;"	v	file:
xMutexHolder	queue.c	/^    TaskHandle_t xMutexHolder;        \/*< The handle of the task that holds the mutex. *\/$/;"	m	struct:SemaphoreData	file:	access:public
xNewLib_reent	tasks.c	/^        struct  _reent xNewLib_reent;$/;"	m	struct:tskTaskControlBlock	typeref:struct:tskTaskControlBlock::_reent	file:	access:public
xNextFreeByte	portable/MemMang/heap_1.c	/^static size_t xNextFreeByte = ( size_t ) 0;$/;"	v	file:
xNextTaskUnblockTime	tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U; \/* Initialised to portMAX_DELAY before the scheduler starts. *\/$/;"	v	file:
xNumOfOverflows	tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;$/;"	v	file:
xNumberOfFreeBlocks	include/portable.h	/^    size_t xNumberOfFreeBlocks;                 \/* The number of free memory blocks within the heap at the time vPortGetHeapStats() is called. *\/$/;"	m	struct:xHeapStats	access:public
xNumberOfSuccessfulAllocations	include/portable.h	/^    size_t xNumberOfSuccessfulAllocations;      \/* The number of calls to pvPortMalloc() that have returned a valid memory block. *\/$/;"	m	struct:xHeapStats	access:public
xNumberOfSuccessfulAllocations	portable/MemMang/heap_4.c	/^PRIVILEGED_DATA static size_t xNumberOfSuccessfulAllocations = 0;$/;"	v	file:
xNumberOfSuccessfulAllocations	portable/MemMang/heap_5.c	/^static size_t xNumberOfSuccessfulAllocations = 0;$/;"	v	file:
xNumberOfSuccessfulFrees	include/portable.h	/^    size_t xNumberOfSuccessfulFrees;            \/* The number of calls to vPortFree() that has successfully freed a block of memory. *\/$/;"	m	struct:xHeapStats	access:public
xNumberOfSuccessfulFrees	portable/MemMang/heap_4.c	/^PRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = 0;$/;"	v	file:
xNumberOfSuccessfulFrees	portable/MemMang/heap_5.c	/^static size_t xNumberOfSuccessfulFrees = 0;$/;"	v	file:
xOverflowCount	include/task.h	/^    BaseType_t xOverflowCount;$/;"	m	struct:xTIME_OUT	access:public
xPassedTicks	croutine.c	/^    static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xPendedTicks	tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;$/;"	v	file:
xPendingReadyCoRoutineList	croutine.c	/^    static List_t xPendingReadyCoRoutineList;                               \/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. *\/$/;"	v	file:
xPendingReadyList	tasks.c	/^PRIVILEGED_DATA static List_t xPendingReadyList;                         \/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. *\/$/;"	v	file:
xPortGetFreeHeapSize	portable/MemMang/heap_1.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f	signature:( void )
xPortGetFreeHeapSize	portable/MemMang/heap_2.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f	signature:( void )
xPortGetFreeHeapSize	portable/MemMang/heap_4.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f	signature:( void )
xPortGetFreeHeapSize	portable/MemMang/heap_5.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f	signature:( void )
xPortGetMinimumEverFreeHeapSize	portable/MemMang/heap_4.c	/^size_t xPortGetMinimumEverFreeHeapSize( void )$/;"	f	signature:( void )
xPortGetMinimumEverFreeHeapSize	portable/MemMang/heap_5.c	/^size_t xPortGetMinimumEverFreeHeapSize( void )$/;"	f	signature:( void )
xPortRaisePrivilege	portable/Common/mpu_wrappers.c	/^BaseType_t xPortRaisePrivilege( void ) \/* FREERTOS_SYSTEM_CALL *\/$/;"	f	signature:( void )
xPortSetInterruptMask	portable/ThirdParty/GCC/Posix/port.c	/^portBASE_TYPE xPortSetInterruptMask( void )$/;"	f	signature:( void )
xPortSetInterruptMask	portable/ThirdParty/GCC/Posix/portmacro.h	/^extern portBASE_TYPE xPortSetInterruptMask( void );$/;"	p	signature:( void )
xPortStartScheduler	portable/ThirdParty/GCC/Posix/port.c	/^portBASE_TYPE xPortStartScheduler( void )$/;"	f	signature:( void )
xQUEUE	queue.c	/^} xQUEUE;$/;"	t	typeref:struct:QueueDefinition	file:
xQueue	queue.c	/^        QueuePointers_t xQueue;     \/*< Data required exclusively when this structure is used as a queue. *\/$/;"	m	union:QueueDefinition::__anon2	file:	access:public
xQueueAddToSet	include/mpu_wrappers.h	110;"	d
xQueueAddToSet	queue.c	/^    BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,$/;"	f	signature:( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
xQueueCRReceive	include/queue.h	/^BaseType_t xQueueCRReceive( QueueHandle_t xQueue,$/;"	p	signature:( QueueHandle_t xQueue, void * pvBuffer, TickType_t xTicksToWait )
xQueueCRReceive	queue.c	/^    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, void * pvBuffer, TickType_t xTicksToWait )
xQueueCRReceiveFromISR	include/queue.h	/^BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,$/;"	p	signature:( QueueHandle_t xQueue, void * pvBuffer, BaseType_t * pxTaskWoken )
xQueueCRReceiveFromISR	queue.c	/^    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, void * pvBuffer, BaseType_t * pxCoRoutineWoken )
xQueueCRSend	include/queue.h	/^BaseType_t xQueueCRSend( QueueHandle_t xQueue,$/;"	p	signature:( QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait )
xQueueCRSend	queue.c	/^    BaseType_t xQueueCRSend( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait )
xQueueCRSendFromISR	include/queue.h	/^BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,$/;"	p	signature:( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
xQueueCRSendFromISR	queue.c	/^    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
xQueueCreate	include/queue.h	149;"	d
xQueueCreateCountingSemaphore	include/mpu_wrappers.h	102;"	d
xQueueCreateCountingSemaphore	queue.c	/^    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,$/;"	f	signature:( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
xQueueCreateCountingSemaphoreStatic	include/mpu_wrappers.h	103;"	d
xQueueCreateCountingSemaphoreStatic	queue.c	/^    QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,$/;"	f	signature:( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t * pxStaticQueue )
xQueueCreateMutex	include/mpu_wrappers.h	100;"	d
xQueueCreateMutex	queue.c	/^    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )$/;"	f	signature:( const uint8_t ucQueueType )
xQueueCreateMutexStatic	include/mpu_wrappers.h	101;"	d
xQueueCreateMutexStatic	queue.c	/^    QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,$/;"	f	signature:( const uint8_t ucQueueType, StaticQueue_t * pxStaticQueue )
xQueueCreateSet	include/mpu_wrappers.h	109;"	d
xQueueCreateSet	queue.c	/^    QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )$/;"	f	signature:( const UBaseType_t uxEventQueueLength )
xQueueCreateStatic	include/queue.h	235;"	d
xQueueGenericCreate	include/mpu_wrappers.h	107;"	d
xQueueGenericCreate	queue.c	/^    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,$/;"	f	signature:( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
xQueueGenericCreateStatic	include/mpu_wrappers.h	108;"	d
xQueueGenericCreateStatic	queue.c	/^    QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,$/;"	f	signature:( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t * pucQueueStorage, StaticQueue_t * pxStaticQueue, const uint8_t ucQueueType )
xQueueGenericReset	include/mpu_wrappers.h	113;"	d
xQueueGenericReset	queue.c	/^BaseType_t xQueueGenericReset( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, BaseType_t xNewQueue )
xQueueGenericSend	include/mpu_wrappers.h	93;"	d
xQueueGenericSend	queue.c	/^BaseType_t xQueueGenericSend( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
xQueueGenericSendFromISR	queue.c	/^BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
xQueueGetMutexHolder	include/mpu_wrappers.h	104;"	d
xQueueGetMutexHolder	queue.c	/^    TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )$/;"	f	signature:( QueueHandle_t xSemaphore )
xQueueGetMutexHolderFromISR	queue.c	/^    TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )$/;"	f	signature:( QueueHandle_t xSemaphore )
xQueueGiveFromISR	queue.c	/^BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
xQueueGiveMutexRecursive	include/mpu_wrappers.h	106;"	d
xQueueGiveMutexRecursive	queue.c	/^    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )$/;"	f	signature:( QueueHandle_t xMutex )
xQueueHandle	include/FreeRTOS.h	993;"	d
xQueueIsQueueEmptyFromISR	queue.c	/^BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )$/;"	f	signature:( const QueueHandle_t xQueue )
xQueueIsQueueFullFromISR	queue.c	/^BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )$/;"	f	signature:( const QueueHandle_t xQueue )
xQueueOverwrite	include/queue.h	568;"	d
xQueueOverwriteFromISR	include/queue.h	1168;"	d
xQueuePeek	include/mpu_wrappers.h	95;"	d
xQueuePeek	queue.c	/^BaseType_t xQueuePeek( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
xQueuePeekFromISR	queue.c	/^BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, void * const pvBuffer )
xQueueReceive	include/mpu_wrappers.h	94;"	d
xQueueReceive	queue.c	/^BaseType_t xQueueReceive( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
xQueueReceiveFromISR	queue.c	/^BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
xQueueRegistry	queue.c	/^    PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];$/;"	v
xQueueRegistryItem	queue.c	/^    } xQueueRegistryItem;$/;"	t	typeref:struct:QUEUE_REGISTRY_ITEM	file:
xQueueRemoveFromSet	include/mpu_wrappers.h	111;"	d
xQueueRemoveFromSet	queue.c	/^    BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore,$/;"	f	signature:( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
xQueueReset	include/queue.h	1481;"	d
xQueueSelectFromSet	include/mpu_wrappers.h	112;"	d
xQueueSelectFromSet	queue.c	/^    QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,$/;"	f	signature:( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
xQueueSelectFromSetFromISR	queue.c	/^    QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )$/;"	f	signature:( QueueSetHandle_t xQueueSet )
xQueueSemaphoreTake	include/mpu_wrappers.h	96;"	d
xQueueSemaphoreTake	queue.c	/^BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,$/;"	f	signature:( QueueHandle_t xQueue, TickType_t xTicksToWait )
xQueueSend	include/queue.h	484;"	d
xQueueSendFromISR	include/queue.h	1243;"	d
xQueueSendToBack	include/queue.h	399;"	d
xQueueSendToBackFromISR	include/queue.h	1080;"	d
xQueueSendToFront	include/queue.h	316;"	d
xQueueSendToFrontFromISR	include/queue.h	1008;"	d
xQueueSetHandle	include/FreeRTOS.h	995;"	d
xQueueSetMemberHandle	include/FreeRTOS.h	996;"	d
xQueueTakeMutexRecursive	include/mpu_wrappers.h	105;"	d
xQueueTakeMutexRecursive	queue.c	/^    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,$/;"	f	signature:( QueueHandle_t xMutex, TickType_t xTicksToWait )
xRegions	include/task.h	/^    MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];$/;"	m	struct:xTASK_PARAMETERS	access:public
xResumeSignals	portable/ThirdParty/GCC/Posix/port.c	/^static sigset_t xResumeSignals;$/;"	v	file:
xSTATIC_EVENT_GROUP	include/FreeRTOS.h	/^typedef struct xSTATIC_EVENT_GROUP$/;"	s
xSTATIC_EVENT_GROUP::ucDummy4	include/FreeRTOS.h	/^        uint8_t ucDummy4;$/;"	m	struct:xSTATIC_EVENT_GROUP	access:public
xSTATIC_EVENT_GROUP::uxDummy3	include/FreeRTOS.h	/^        UBaseType_t uxDummy3;$/;"	m	struct:xSTATIC_EVENT_GROUP	access:public
xSTATIC_EVENT_GROUP::xDummy1	include/FreeRTOS.h	/^    TickType_t xDummy1;$/;"	m	struct:xSTATIC_EVENT_GROUP	access:public
xSTATIC_EVENT_GROUP::xDummy2	include/FreeRTOS.h	/^    StaticList_t xDummy2;$/;"	m	struct:xSTATIC_EVENT_GROUP	access:public
xSTATIC_LIST	include/FreeRTOS.h	/^typedef struct xSTATIC_LIST$/;"	s
xSTATIC_LIST::pvDummy3	include/FreeRTOS.h	/^    void * pvDummy3;$/;"	m	struct:xSTATIC_LIST	access:public
xSTATIC_LIST::uxDummy2	include/FreeRTOS.h	/^    UBaseType_t uxDummy2;$/;"	m	struct:xSTATIC_LIST	access:public
xSTATIC_LIST::xDummy1	include/FreeRTOS.h	/^        TickType_t xDummy1;$/;"	m	struct:xSTATIC_LIST	access:public
xSTATIC_LIST::xDummy4	include/FreeRTOS.h	/^    StaticMiniListItem_t xDummy4;$/;"	m	struct:xSTATIC_LIST	access:public
xSTATIC_LIST::xDummy5	include/FreeRTOS.h	/^        TickType_t xDummy5;$/;"	m	struct:xSTATIC_LIST	access:public
xSTATIC_LIST_ITEM	include/FreeRTOS.h	/^struct xSTATIC_LIST_ITEM$/;"	s
xSTATIC_LIST_ITEM::pvDummy3	include/FreeRTOS.h	/^    void * pvDummy3[ 4 ];$/;"	m	struct:xSTATIC_LIST_ITEM	access:public
xSTATIC_LIST_ITEM::xDummy1	include/FreeRTOS.h	/^        TickType_t xDummy1;$/;"	m	struct:xSTATIC_LIST_ITEM	access:public
xSTATIC_LIST_ITEM::xDummy2	include/FreeRTOS.h	/^    TickType_t xDummy2;$/;"	m	struct:xSTATIC_LIST_ITEM	access:public
xSTATIC_LIST_ITEM::xDummy4	include/FreeRTOS.h	/^        TickType_t xDummy4;$/;"	m	struct:xSTATIC_LIST_ITEM	access:public
xSTATIC_MINI_LIST_ITEM	include/FreeRTOS.h	/^struct xSTATIC_MINI_LIST_ITEM$/;"	s
xSTATIC_MINI_LIST_ITEM::pvDummy3	include/FreeRTOS.h	/^    void * pvDummy3[ 2 ];$/;"	m	struct:xSTATIC_MINI_LIST_ITEM	access:public
xSTATIC_MINI_LIST_ITEM::xDummy1	include/FreeRTOS.h	/^        TickType_t xDummy1;$/;"	m	struct:xSTATIC_MINI_LIST_ITEM	access:public
xSTATIC_MINI_LIST_ITEM::xDummy2	include/FreeRTOS.h	/^    TickType_t xDummy2;$/;"	m	struct:xSTATIC_MINI_LIST_ITEM	access:public
xSTATIC_QUEUE	include/FreeRTOS.h	/^typedef struct xSTATIC_QUEUE$/;"	s
xSTATIC_QUEUE::__anon6::pvDummy2	include/FreeRTOS.h	/^        void * pvDummy2;$/;"	m	union:xSTATIC_QUEUE::__anon6	access:public
xSTATIC_QUEUE::__anon6::uxDummy2	include/FreeRTOS.h	/^        UBaseType_t uxDummy2;$/;"	m	union:xSTATIC_QUEUE::__anon6	access:public
xSTATIC_QUEUE::pvDummy1	include/FreeRTOS.h	/^    void * pvDummy1[ 3 ];$/;"	m	struct:xSTATIC_QUEUE	access:public
xSTATIC_QUEUE::pvDummy7	include/FreeRTOS.h	/^        void * pvDummy7;$/;"	m	struct:xSTATIC_QUEUE	access:public
xSTATIC_QUEUE::u	include/FreeRTOS.h	/^    } u;$/;"	m	struct:xSTATIC_QUEUE	typeref:union:xSTATIC_QUEUE::__anon6	access:public
xSTATIC_QUEUE::ucDummy5	include/FreeRTOS.h	/^    uint8_t ucDummy5[ 2 ];$/;"	m	struct:xSTATIC_QUEUE	access:public
xSTATIC_QUEUE::ucDummy6	include/FreeRTOS.h	/^        uint8_t ucDummy6;$/;"	m	struct:xSTATIC_QUEUE	access:public
xSTATIC_QUEUE::ucDummy9	include/FreeRTOS.h	/^        uint8_t ucDummy9;$/;"	m	struct:xSTATIC_QUEUE	access:public
xSTATIC_QUEUE::uxDummy4	include/FreeRTOS.h	/^    UBaseType_t uxDummy4[ 3 ];$/;"	m	struct:xSTATIC_QUEUE	access:public
xSTATIC_QUEUE::uxDummy8	include/FreeRTOS.h	/^        UBaseType_t uxDummy8;$/;"	m	struct:xSTATIC_QUEUE	access:public
xSTATIC_QUEUE::xDummy3	include/FreeRTOS.h	/^    StaticList_t xDummy3[ 2 ];$/;"	m	struct:xSTATIC_QUEUE	access:public
xSTATIC_STREAM_BUFFER	include/FreeRTOS.h	/^typedef struct xSTATIC_STREAM_BUFFER$/;"	s
xSTATIC_STREAM_BUFFER::pvDummy2	include/FreeRTOS.h	/^    void * pvDummy2[ 3 ];$/;"	m	struct:xSTATIC_STREAM_BUFFER	access:public
xSTATIC_STREAM_BUFFER::ucDummy3	include/FreeRTOS.h	/^    uint8_t ucDummy3;$/;"	m	struct:xSTATIC_STREAM_BUFFER	access:public
xSTATIC_STREAM_BUFFER::uxDummy1	include/FreeRTOS.h	/^    size_t uxDummy1[ 4 ];$/;"	m	struct:xSTATIC_STREAM_BUFFER	access:public
xSTATIC_STREAM_BUFFER::uxDummy4	include/FreeRTOS.h	/^        UBaseType_t uxDummy4;$/;"	m	struct:xSTATIC_STREAM_BUFFER	access:public
xSTATIC_TCB	include/FreeRTOS.h	/^typedef struct xSTATIC_TCB$/;"	s
xSTATIC_TCB::iDummy22	include/FreeRTOS.h	/^        int iDummy22;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::pvDummy15	include/FreeRTOS.h	/^        void * pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::pxDummy1	include/FreeRTOS.h	/^    void * pxDummy1;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::pxDummy14	include/FreeRTOS.h	/^        void * pxDummy14;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::pxDummy6	include/FreeRTOS.h	/^    void * pxDummy6;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::pxDummy8	include/FreeRTOS.h	/^        void * pxDummy8;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::ucDummy19	include/FreeRTOS.h	/^        uint8_t ucDummy19[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::ucDummy21	include/FreeRTOS.h	/^        uint8_t ucDummy21;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::ucDummy7	include/FreeRTOS.h	/^    uint8_t ucDummy7[ configMAX_TASK_NAME_LEN ];$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::ulDummy16	include/FreeRTOS.h	/^        uint32_t ulDummy16;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::ulDummy18	include/FreeRTOS.h	/^        uint32_t ulDummy18[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::uxDummy10	include/FreeRTOS.h	/^        UBaseType_t uxDummy10[ 2 ];$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::uxDummy12	include/FreeRTOS.h	/^        UBaseType_t uxDummy12[ 2 ];$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::uxDummy20	include/FreeRTOS.h	/^        uint8_t uxDummy20;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::uxDummy5	include/FreeRTOS.h	/^    UBaseType_t uxDummy5;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::uxDummy9	include/FreeRTOS.h	/^        UBaseType_t uxDummy9;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::xDummy17	include/FreeRTOS.h	/^        struct  _reent xDummy17;$/;"	m	struct:xSTATIC_TCB	typeref:struct:xSTATIC_TCB::_reent	access:public
xSTATIC_TCB::xDummy2	include/FreeRTOS.h	/^        xMPU_SETTINGS xDummy2;$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TCB::xDummy3	include/FreeRTOS.h	/^    StaticListItem_t xDummy3[ 2 ];$/;"	m	struct:xSTATIC_TCB	access:public
xSTATIC_TIMER	include/FreeRTOS.h	/^typedef struct xSTATIC_TIMER$/;"	s
xSTATIC_TIMER::pvDummy1	include/FreeRTOS.h	/^    void * pvDummy1;$/;"	m	struct:xSTATIC_TIMER	access:public
xSTATIC_TIMER::pvDummy5	include/FreeRTOS.h	/^    void * pvDummy5;$/;"	m	struct:xSTATIC_TIMER	access:public
xSTATIC_TIMER::pvDummy6	include/FreeRTOS.h	/^    TaskFunction_t pvDummy6;$/;"	m	struct:xSTATIC_TIMER	access:public
xSTATIC_TIMER::ucDummy8	include/FreeRTOS.h	/^    uint8_t ucDummy8;$/;"	m	struct:xSTATIC_TIMER	access:public
xSTATIC_TIMER::uxDummy7	include/FreeRTOS.h	/^        UBaseType_t uxDummy7;$/;"	m	struct:xSTATIC_TIMER	access:public
xSTATIC_TIMER::xDummy2	include/FreeRTOS.h	/^    StaticListItem_t xDummy2;$/;"	m	struct:xSTATIC_TIMER	access:public
xSTATIC_TIMER::xDummy3	include/FreeRTOS.h	/^    TickType_t xDummy3;$/;"	m	struct:xSTATIC_TIMER	access:public
xSchedulerEnd	portable/ThirdParty/GCC/Posix/port.c	/^static portBASE_TYPE xSchedulerEnd = pdFALSE;$/;"	v	file:
xSchedulerOriginalSignalMask	portable/ThirdParty/GCC/Posix/port.c	/^static sigset_t xSchedulerOriginalSignalMask;$/;"	v	file:
xSchedulerRunning	tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;$/;"	v	file:
xSemaphore	queue.c	/^        SemaphoreData_t xSemaphore; \/*< Data required exclusively when this structure is used as a semaphore. *\/$/;"	m	union:QueueDefinition::__anon2	file:	access:public
xSemaphoreCreateBinary	include/semphr.h	167;"	d
xSemaphoreCreateBinaryStatic	include/semphr.h	228;"	d
xSemaphoreCreateCounting	include/semphr.h	1025;"	d
xSemaphoreCreateCountingStatic	include/semphr.h	1112;"	d
xSemaphoreCreateMutex	include/semphr.h	735;"	d
xSemaphoreCreateMutexStatic	include/semphr.h	798;"	d
xSemaphoreCreateRecursiveMutex	include/semphr.h	868;"	d
xSemaphoreCreateRecursiveMutexStatic	include/semphr.h	943;"	d
xSemaphoreGetMutexHolder	include/semphr.h	1146;"	d
xSemaphoreGetMutexHolderFromISR	include/semphr.h	1159;"	d
xSemaphoreGive	include/semphr.h	460;"	d
xSemaphoreGiveFromISR	include/semphr.h	640;"	d
xSemaphoreGiveRecursive	include/semphr.h	547;"	d
xSemaphoreHandle	include/FreeRTOS.h	994;"	d
xSemaphoreTake	include/semphr.h	298;"	d
xSemaphoreTakeFromISR	include/semphr.h	675;"	d
xSemaphoreTakeRecursive	include/semphr.h	394;"	d
xSizeInBytes	include/portable.h	/^    size_t xSizeInBytes;$/;"	m	struct:HeapRegion	access:public
xSizeOfLargestFreeBlockInBytes	include/portable.h	/^    size_t xSizeOfLargestFreeBlockInBytes;      \/* The maximum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. *\/$/;"	m	struct:xHeapStats	access:public
xSizeOfSmallestFreeBlockInBytes	include/portable.h	/^    size_t xSizeOfSmallestFreeBlockInBytes;     \/* The minimum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. *\/$/;"	m	struct:xHeapStats	access:public
xStart	portable/MemMang/heap_2.c	/^static BlockLink_t xStart, xEnd;$/;"	v	file:
xStart	portable/MemMang/heap_4.c	/^PRIVILEGED_DATA static BlockLink_t xStart, * pxEnd = NULL;$/;"	v	file:
xStart	portable/MemMang/heap_5.c	/^static BlockLink_t xStart, * pxEnd = NULL;$/;"	v	file:
xStateListItem	tasks.c	/^    ListItem_t xStateListItem;                  \/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). *\/$/;"	m	struct:tskTaskControlBlock	file:	access:public
xStreamBufferBytesAvailable	include/mpu_wrappers.h	155;"	d
xStreamBufferBytesAvailable	stream_buffer.c	/^size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
xStreamBufferCreate	include/stream_buffer.h	140;"	d
xStreamBufferCreateStatic	include/stream_buffer.h	221;"	d
xStreamBufferGenericCreate	include/mpu_wrappers.h	157;"	d
xStreamBufferGenericCreate	stream_buffer.c	/^    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,$/;"	f	signature:( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
xStreamBufferGenericCreateStatic	include/mpu_wrappers.h	158;"	d
xStreamBufferGenericCreateStatic	stream_buffer.c	/^    StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,$/;"	f	signature:( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t * const pucStreamBufferStorageArea, StaticStreamBuffer_t * const pxStaticStreamBuffer )
xStreamBufferIsEmpty	include/mpu_wrappers.h	152;"	d
xStreamBufferIsEmpty	stream_buffer.c	/^BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
xStreamBufferIsFull	include/mpu_wrappers.h	151;"	d
xStreamBufferIsFull	stream_buffer.c	/^BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
xStreamBufferNextMessageLengthBytes	include/mpu_wrappers.h	149;"	d
xStreamBufferNextMessageLengthBytes	stream_buffer.c	/^size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
xStreamBufferReceive	include/mpu_wrappers.h	148;"	d
xStreamBufferReceive	stream_buffer.c	/^size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait )
xStreamBufferReceiveCompletedFromISR	stream_buffer.c	/^BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, BaseType_t * pxHigherPriorityTaskWoken )
xStreamBufferReceiveFromISR	stream_buffer.c	/^size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, BaseType_t * const pxHigherPriorityTaskWoken )
xStreamBufferReset	include/mpu_wrappers.h	153;"	d
xStreamBufferReset	stream_buffer.c	/^BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
xStreamBufferSend	include/mpu_wrappers.h	147;"	d
xStreamBufferSend	stream_buffer.c	/^size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait )
xStreamBufferSendCompletedFromISR	stream_buffer.c	/^BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, BaseType_t * pxHigherPriorityTaskWoken )
xStreamBufferSendFromISR	stream_buffer.c	/^size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, BaseType_t * const pxHigherPriorityTaskWoken )
xStreamBufferSetTriggerLevel	include/mpu_wrappers.h	156;"	d
xStreamBufferSetTriggerLevel	stream_buffer.c	/^BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
xStreamBufferSpacesAvailable	include/mpu_wrappers.h	154;"	d
xStreamBufferSpacesAvailable	stream_buffer.c	/^size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )$/;"	f	signature:( StreamBufferHandle_t xStreamBuffer )
xSuspendedTaskList	tasks.c	/^    PRIVILEGED_DATA static List_t xSuspendedTaskList; \/*< Tasks that are currently suspended. *\/$/;"	v	file:
xTASK_PARAMETERS	include/task.h	/^typedef struct xTASK_PARAMETERS$/;"	s
xTASK_PARAMETERS::pcName	include/task.h	/^    const char * pcName;     \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_PARAMETERS	access:public
xTASK_PARAMETERS::puxStackBuffer	include/task.h	/^    StackType_t * puxStackBuffer;$/;"	m	struct:xTASK_PARAMETERS	access:public
xTASK_PARAMETERS::pvParameters	include/task.h	/^    void * pvParameters;$/;"	m	struct:xTASK_PARAMETERS	access:public
xTASK_PARAMETERS::pvTaskCode	include/task.h	/^    TaskFunction_t pvTaskCode;$/;"	m	struct:xTASK_PARAMETERS	access:public
xTASK_PARAMETERS::pxTaskBuffer	include/task.h	/^        StaticTask_t * const pxTaskBuffer;$/;"	m	struct:xTASK_PARAMETERS	access:public
xTASK_PARAMETERS::usStackDepth	include/task.h	/^    configSTACK_DEPTH_TYPE usStackDepth;$/;"	m	struct:xTASK_PARAMETERS	access:public
xTASK_PARAMETERS::uxPriority	include/task.h	/^    UBaseType_t uxPriority;$/;"	m	struct:xTASK_PARAMETERS	access:public
xTASK_PARAMETERS::xRegions	include/task.h	/^    MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];$/;"	m	struct:xTASK_PARAMETERS	access:public
xTASK_STATUS	include/task.h	/^typedef struct xTASK_STATUS$/;"	s
xTASK_STATUS::eCurrentState	include/task.h	/^    eTaskState eCurrentState;                        \/* The state in which the task existed when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTASK_STATUS::pcTaskName	include/task.h	/^    const char * pcTaskName;                         \/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTASK_STATUS::pxStackBase	include/task.h	/^    StackType_t * pxStackBase;                       \/* Points to the lowest address of the task's stack area. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTASK_STATUS::ulRunTimeCounter	include/task.h	/^    uint32_t ulRunTimeCounter;                       \/* The total run time allocated to the task so far, as defined by the run time stats clock.  See https:\/\/www.FreeRTOS.org\/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTASK_STATUS::usStackHighWaterMark	include/task.h	/^    configSTACK_DEPTH_TYPE usStackHighWaterMark;     \/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTASK_STATUS::uxBasePriority	include/task.h	/^    UBaseType_t uxBasePriority;                      \/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTASK_STATUS::uxCurrentPriority	include/task.h	/^    UBaseType_t uxCurrentPriority;                   \/* The priority at which the task was running (may be inherited) when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTASK_STATUS::xHandle	include/task.h	/^    TaskHandle_t xHandle;                            \/* The handle of the task to which the rest of the information in the structure relates. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTASK_STATUS::xTaskNumber	include/task.h	/^    UBaseType_t xTaskNumber;                         \/* A number unique to the task. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTIMER	timers.c	/^    } xTIMER;$/;"	t	typeref:struct:tmrTimerControl	file:
xTIME_OUT	include/task.h	/^typedef struct xTIME_OUT$/;"	s
xTIME_OUT::xOverflowCount	include/task.h	/^    BaseType_t xOverflowCount;$/;"	m	struct:xTIME_OUT	access:public
xTIME_OUT::xTimeOnEntering	include/task.h	/^    TickType_t xTimeOnEntering;$/;"	m	struct:xTIME_OUT	access:public
xTail	stream_buffer.c	/^    volatile size_t xTail;                       \/* Index to the next item to read within the buffer. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
xTaskAbortDelay	include/mpu_wrappers.h	55;"	d
xTaskAbortDelay	tasks.c	/^    BaseType_t xTaskAbortDelay( TaskHandle_t xTask )$/;"	f	signature:( TaskHandle_t xTask )
xTaskCallApplicationTaskHook	include/mpu_wrappers.h	74;"	d
xTaskCallApplicationTaskHook	tasks.c	/^    BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, void * pvParameter )
xTaskCatchUpTicks	include/mpu_wrappers.h	85;"	d
xTaskCatchUpTicks	tasks.c	/^BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )$/;"	f	signature:( TickType_t xTicksToCatchUp )
xTaskCheckForTimeOut	include/mpu_wrappers.h	89;"	d
xTaskCheckForTimeOut	tasks.c	/^BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,$/;"	f	signature:( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
xTaskCreate	include/mpu_wrappers.h	50;"	d
xTaskCreate	tasks.c	/^    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,$/;"	f	signature:( TaskFunction_t pxTaskCode, const char * const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask )
xTaskCreateRestricted	tasks.c	/^    BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,$/;"	f	signature:( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t * pxCreatedTask )
xTaskCreateRestrictedStatic	tasks.c	/^    BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,$/;"	f	signature:( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t * pxCreatedTask )
xTaskCreateStatic	include/mpu_wrappers.h	51;"	d
xTaskCreateStatic	tasks.c	/^    TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,$/;"	f	signature:( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer )
xTaskDelayUntil	include/mpu_wrappers.h	54;"	d
xTaskDelayUntil	tasks.c	/^    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,$/;"	f	signature:( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
xTaskGenericNotify	include/mpu_wrappers.h	80;"	d
xTaskGenericNotify	tasks.c	/^    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,$/;"	f	signature:( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t * pulPreviousNotificationValue )
xTaskGenericNotifyFromISR	tasks.c	/^    BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,$/;"	f	signature:( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t * pulPreviousNotificationValue, BaseType_t * pxHigherPriorityTaskWoken )
xTaskGenericNotifyStateClear	include/mpu_wrappers.h	83;"	d
xTaskGenericNotifyStateClear	tasks.c	/^    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,$/;"	f	signature:( TaskHandle_t xTask, UBaseType_t uxIndexToClear )
xTaskGenericNotifyWait	include/mpu_wrappers.h	81;"	d
xTaskGenericNotifyWait	tasks.c	/^    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,$/;"	f	signature:( UBaseType_t uxIndexToWait, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t * pulNotificationValue, TickType_t xTicksToWait )
xTaskGetApplicationTaskTag	include/mpu_wrappers.h	71;"	d
xTaskGetApplicationTaskTag	tasks.c	/^    TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )$/;"	f	signature:( TaskHandle_t xTask )
xTaskGetApplicationTaskTagFromISR	tasks.c	/^    TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )$/;"	f	signature:( TaskHandle_t xTask )
xTaskGetCurrentTaskHandle	include/mpu_wrappers.h	87;"	d
xTaskGetCurrentTaskHandle	tasks.c	/^    TaskHandle_t xTaskGetCurrentTaskHandle( void )$/;"	f	signature:( void )
xTaskGetHandle	include/mpu_wrappers.h	67;"	d
xTaskGetHandle	tasks.c	/^    TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	signature:( const char * pcNameToQuery )
xTaskGetIdleRunTimeCounter	include/FreeRTOS.h	1009;"	d
xTaskGetIdleTaskHandle	include/mpu_wrappers.h	75;"	d
xTaskGetIdleTaskHandle	tasks.c	/^    TaskHandle_t xTaskGetIdleTaskHandle( void )$/;"	f	signature:( void )
xTaskGetSchedulerState	include/mpu_wrappers.h	90;"	d
xTaskGetSchedulerState	tasks.c	/^    BaseType_t xTaskGetSchedulerState( void )$/;"	f	signature:( void )
xTaskGetTickCount	include/mpu_wrappers.h	64;"	d
xTaskGetTickCount	tasks.c	/^TickType_t xTaskGetTickCount( void )$/;"	f	signature:( void )
xTaskGetTickCountFromISR	tasks.c	/^TickType_t xTaskGetTickCountFromISR( void )$/;"	f	signature:( void )
xTaskHandle	include/FreeRTOS.h	992;"	d
xTaskIncrementTick	tasks.c	/^BaseType_t xTaskIncrementTick( void )$/;"	f	signature:( void )
xTaskNotify	include/task.h	2028;"	d
xTaskNotifyAndQuery	include/task.h	2055;"	d
xTaskNotifyAndQueryFromISR	include/task.h	2206;"	d
xTaskNotifyAndQueryIndexed	include/task.h	2057;"	d
xTaskNotifyAndQueryIndexedFromISR	include/task.h	2204;"	d
xTaskNotifyFromISR	include/task.h	2177;"	d
xTaskNotifyGive	include/task.h	2393;"	d
xTaskNotifyGiveIndexed	include/task.h	2395;"	d
xTaskNotifyIndexed	include/task.h	2030;"	d
xTaskNotifyIndexedFromISR	include/task.h	2179;"	d
xTaskNotifyStateClear	include/task.h	2648;"	d
xTaskNotifyStateClearIndexed	include/task.h	2650;"	d
xTaskNotifyWait	include/task.h	2318;"	d
xTaskNotifyWaitIndexed	include/task.h	2320;"	d
xTaskNumber	include/task.h	/^    UBaseType_t xTaskNumber;                         \/* A number unique to the task. *\/$/;"	m	struct:xTASK_STATUS	access:public
xTaskParameters	include/FreeRTOS.h	999;"	d
xTaskPriorityDisinherit	tasks.c	/^    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )$/;"	f	signature:( TaskHandle_t const pxMutexHolder )
xTaskPriorityInherit	tasks.c	/^    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )$/;"	f	signature:( TaskHandle_t const pxMutexHolder )
xTaskRemoveFromEventList	tasks.c	/^BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )$/;"	f	signature:( const List_t * const pxEventList )
xTaskResumeAll	include/mpu_wrappers.h	63;"	d
xTaskResumeAll	tasks.c	/^BaseType_t xTaskResumeAll( void )$/;"	f	signature:( void )
xTaskResumeFromISR	tasks.c	/^    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )$/;"	f	signature:( TaskHandle_t xTaskToResume )
xTaskStatusType	include/FreeRTOS.h	1000;"	d
xTaskWaitingToReceive	stream_buffer.c	/^    volatile TaskHandle_t xTaskWaitingToReceive; \/* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
xTaskWaitingToSend	stream_buffer.c	/^    volatile TaskHandle_t xTaskWaitingToSend;    \/* Holds the handle of a task waiting to send data to a message buffer that is full. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
xTasksWaitingForBits	event_groups.c	/^    List_t xTasksWaitingForBits; \/*< List of tasks waiting for a bit to be set. *\/$/;"	m	struct:EventGroupDef_t	file:	access:public
xTasksWaitingTermination	tasks.c	/^    PRIVILEGED_DATA static List_t xTasksWaitingTermination; \/*< Tasks that have been deleted - but their memory not yet freed. *\/$/;"	v	file:
xTasksWaitingToReceive	queue.c	/^    List_t xTasksWaitingToReceive;          \/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:	access:public
xTasksWaitingToSend	queue.c	/^    List_t xTasksWaitingToSend;             \/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:	access:public
xTickCount	tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;$/;"	v	file:
xTimeOnEntering	include/task.h	/^    TickType_t xTimeOnEntering;$/;"	m	struct:xTIME_OUT	access:public
xTimeOutType	include/FreeRTOS.h	997;"	d
xTimerChangePeriod	include/timers.h	633;"	d
xTimerChangePeriodFromISR	include/timers.h	1022;"	d
xTimerCreate	include/mpu_wrappers.h	122;"	d
xTimerCreate	timers.c	/^        TimerHandle_t xTimerCreate( const char * const pcTimerName, \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	signature:( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction )
xTimerCreateStatic	include/mpu_wrappers.h	123;"	d
xTimerCreateStatic	timers.c	/^        TimerHandle_t xTimerCreateStatic( const char * const pcTimerName, \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	signature:( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t * pxTimerBuffer )
xTimerCreateTimerTask	timers.c	/^    BaseType_t xTimerCreateTimerTask( void )$/;"	f	signature:( void )
xTimerDelete	include/timers.h	672;"	d
xTimerGenericCommand	include/mpu_wrappers.h	134;"	d
xTimerGenericCommand	timers.c	/^    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,$/;"	f	signature:( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
xTimerGetExpiryTime	include/mpu_wrappers.h	133;"	d
xTimerGetExpiryTime	timers.c	/^    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )$/;"	f	signature:( TimerHandle_t xTimer )
xTimerGetPeriod	include/mpu_wrappers.h	132;"	d
xTimerGetPeriod	timers.c	/^    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )$/;"	f	signature:( TimerHandle_t xTimer )
xTimerGetTimerDaemonTaskHandle	include/mpu_wrappers.h	127;"	d
xTimerGetTimerDaemonTaskHandle	timers.c	/^    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )$/;"	f	signature:( void )
xTimerHandle	include/FreeRTOS.h	1001;"	d
xTimerIsTimerActive	include/mpu_wrappers.h	126;"	d
xTimerIsTimerActive	timers.c	/^    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )$/;"	f	signature:( TimerHandle_t xTimer )
xTimerListItem	timers.c	/^        ListItem_t xTimerListItem;                  \/*<< Standard linked list item as used by all kernel features for event management. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
xTimerParameters	timers.c	/^            TimerParameter_t xTimerParameters;$/;"	m	union:tmrTimerQueueMessage::__anon1	file:	access:public
xTimerPendFunctionCall	include/mpu_wrappers.h	128;"	d
xTimerPendFunctionCall	timers.c	/^        BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,$/;"	f	signature:( PendedFunction_t xFunctionToPend, void * pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
xTimerPendFunctionCallFromISR	timers.c	/^        BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,$/;"	f	signature:( PendedFunction_t xFunctionToPend, void * pvParameter1, uint32_t ulParameter2, BaseType_t * pxHigherPriorityTaskWoken )
xTimerPeriodInTicks	timers.c	/^        TickType_t xTimerPeriodInTicks;             \/*<< How quickly and often the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:	access:public
xTimerQueue	timers.c	/^    PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;$/;"	v	file:
xTimerReset	include/timers.h	797;"	d
xTimerResetFromISR	include/timers.h	1109;"	d
xTimerStart	include/timers.h	509;"	d
xTimerStartFromISR	include/timers.h	884;"	d
xTimerStop	include/timers.h	552;"	d
xTimerStopFromISR	include/timers.h	948;"	d
xTimerTaskHandle	timers.c	/^    PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;$/;"	v	file:
xTriggerLevelBytes	stream_buffer.c	/^    size_t xTriggerLevelBytes;                   \/* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. *\/$/;"	m	struct:StreamBufferDef_t	file:	access:public
xYieldPending	tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;$/;"	v	file:
